---
slug: dispersion
title: Dispersion
tags: [CSS, Animation]
unlisted: true
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

이 문서는 색인되지 않습니다.

{/* truncate */}

아직 이 효과의 가장 중요한 부분을 다루지 않았습니다! 파티클들은 중앙에서 모든 방향으로 퍼져야 합니다.

아래는 현재까지 구현된 코드입니다.

<Tabs>
  <TabItem value="index.html" label="index.html">
    ```html 
    <style>
    @keyframes fadeToTransparent {
        to {
            opacity: 0;
        }
    }
    .particle {
        position: absolute;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: white;
        transform: translate(-50%, -50%);
        pointer-events: none;
        animation: fadeToTransparent forwards;
    }
    </style>

    <button class="particleButton">
        <!-- 하트 svg -->
    </button>
    ```

  </TabItem>

<TabItem value="index.js" label="index.js">
```js
import { random, range } from 'lodash';
const btn = document.querySelector('.particleButton');
const FADE_DURATION = 1000;
btn.addEventListener('click', () => {
    btn.classList.toggle('liked');
    const isLiked = btn.classList.contains('liked');
    if (!isLiked) {
        return;
    }
    const particles = [];
    range(5).forEach(() => {
        const particle = document.createElement('span');
        particle.classList.add('particle');
        particle.style.top = random(0, 100) + '%';
        particle.style.left = random(0, 100) + '%';
        particle.style.animationDuration = FADE_DURATION + 'ms';
        btn.appendChild(particle);
        particles.push(particle);
    });
    window.setTimeout(() => {
        particles.forEach((particle) => {
            particle.remove();
        });
    }, FADE_DURATION + 200);
});
```
</TabItem>
<TabItem value="index.css" label="index.css">
```css
html {
    --red: oklch(0.65 0.3 19.41);
}
body {
    display: grid;
    place-content: center;
    height: 100vh;
    background: hsl(210deg 15% 6%);
}
.particleButton {
    position: relative;
    padding: 16px;
    background: transparent;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    &:hover {
        background: hsl(0deg 0% 100% / 0.1);
        path {
            stroke: var(--red);
        }
    }
    &.liked path {
        fill: var(--red);
        stroke: var(--red);
    }
}
.particleButton svg {
    position: relative;
    display: block;
    width: 3rem;
    height: 3rem;
}
.visually-hidden:not(:focus):not(:active) {
    position: absolute;
    width: 1px;
    height: 1px;
    overflow: hidden;
    clip: rect(0 0 0 0);
    clip-path: inset(50%);
    white-space: nowrap;
}
```
</TabItem>
</Tabs>

위의 구현에서 `top`과 `left`에 랜덤한 값을 대입하였고, 해당 값에 파티클들이 바로 나타나게 됩니다.
이제 버튼의 중심으로부터 퍼져나가는 효과를 적용하는 몇가지 방법을 살펴보겠습니다.

첫번째 방법은 `setTimeout`과 함께 CSS transition을 사용하는 방법 입니다.

```js
range(5).forEach(() => {
  const particle = document.createElement('span');
  particle.classList.add('particle');

  // Set the starting position
  particle.style.top = '50%';
  particle.style.left = '50%';

  // Set up the animation properties
  particle.style.transition = 'top 500ms, left 500ms';
  particle.style.animationDuration = FADE_DURATION + 'ms';

  // Wait for those previous changes to be flushed to the
  // DOM before updating their position:
  window.setTimeout(() => {
    particle.style.top = random(0, 100) + '%';
    particle.style.left = random(0, 100) + '%';
  }, 1);

  btn.appendChild(particle);
  particles.push(particle);
});
```

이 방법은 동작하지만 이상적은 방법은 아닙니다. `window.requestAnimationFrame`을 사용하면 조금 더 나을 수 있지만 사실 좀 더 나은 접근방법이 있습니다.

문제는 CSS transition이 상태들 사이의 전이를 위한 것이라는 것입니다. 예를 들어, 호버 효과는 다른 배경색을 적용할 수 있으므로 기본 상태와 호버 상태 사이를 전환할 수 있습니다.

이 경우에 파티클들은 사실 상태간의 전이가 아닙니다. 상태간의 전이라기보다는 애니메이션의 진입과 관련되어 있습니다.

앞에서 본 코드의 변경사항을 제거하고 새로운 접근법을 적용해 보겠습니다.

```css
@keyframes disperse {
  from {
    top: 50%;
    left: 50%;
  }
  to {
    /* TODO */
  }
}

.particle {
  animation:
    fadeToTransparent forwards,
    disperse;
}
```

Keyframe 애니메이션을 이용하는 방법이 까다로운 점은 모든 `.particle` 인스턴스가 동일한 keyframe 정의를 사용한다는 것 입니다.
`to` 블록에 랜덤한 top/left 값이 들어가야하는데, 이렇게 되면 모든 파티클들이 동일한 위치로 이동하게 됩니다.

[Partial Keyframes](../2025-10-07-partial-keyframes/index.mdx)을 사용하면 문제를 해결할 수 있습니다. 파티클의 최종위치를 정의할 필요가 없습니다.

```CSS
@keyframes fromCenter {
    from {
        top: 50%;
        left: 50%;
    }
}
```

파티클의 최종위치를 JavaScript를 통해 인라인 스타일로 정의했기 때문에 이 방식은 동작합니다.

```javascript
particle.style.top = random(0, 100) + '%';
particle.style.left = random(0, 100) + '%';
```

각각의 파티클들은 50%50%에서 각자 정의된 랜덤한 값으로 이동하게 됩니다.

이 방법의 유일한 문제는 두개의 애니메이션(중심에서 퍼져나가는 애니메이션, 사라지는 애니메이션)이 동일한 duration을 공유한다는 것입니다 (FADE_DURATION으로 설정된 값).
퍼지는 애니메이션은 빠르게, 사라지는 애니메이션은 느리게 동작하면 더 좋을거 같습니다.

이 문제는 CSS 커스텀 프로퍼티를 사용하면 해결할 수 있습니다. 아래의 예시를 통해 살펴보겠습니다.

CSS 변수(CSS 커스텀 프로퍼티)를 사용하여 애니메이션별로 올바른 fade duration을 적용하겠습니다.

<Tabs>
  <TabItem value="index.html" label="index.html">
    ```html 
    <style>
    @keyframes fadeToTransparent {
        to {
            opacity: 0;
        }
    }
    @keyframes fromCenter {
        from {
            top: 50%;
            left: 50%;
        }
    }
    .particle {
        position: absolute;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: white;
        transform: translate(-50%, -50%);
        pointer-events: none;
        animation: fadeToTransparent var(--fade-duration) forwards, fromCenter 500ms;
    }
    </style>

    <button class="particleButton">
        <!-- 하트 svg -->
    </button>
    ```

  </TabItem>

<TabItem value="index.js" label="index.js">
```js
import { random, range } from 'lodash';
const btn = document.querySelector('.particleButton');
const FADE_DURATION = 1000;
btn.addEventListener('click', () => {
    btn.classList.toggle('liked');
    const isLiked = btn.classList.contains('liked');
    if (!isLiked) {
        return;
    }
    const particles = [];
    range(5).forEach(() => {
        const particle = document.createElement('span');
        particle.classList.add('particle');
        particle.style.top = random(0, 100) + '%';
        particle.style.left = random(0, 100) + '%';
        particle.style.setProperty('--fade-duration', FADE_DURATION + 'ms');
        btn.appendChild(particle);
        particles.push(particle);
    });
    window.setTimeout(() => {
        particles.forEach((particle) => {
            particle.remove();
        });
    }, FADE_DURATION + 200);
});
```
</TabItem>
<TabItem value="index.css" label="index.css">
```css
html {
    --red: oklch(0.65 0.3 19.41);
}
body {
    display: grid;
    place-content: center;
    height: 100vh;
    background: hsl(210deg 15% 6%);
}
.particleButton {
    position: relative;
    padding: 16px;
    background: transparent;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    &:hover {
        background: hsl(0deg 0% 100% / 0.1);
        path {
            stroke: var(--red);
        }
    }
    &.liked path {
        fill: var(--red);
        stroke: var(--red);
    }
}
.particleButton svg {
    position: relative;
    display: block;
    width: 3rem;
    height: 3rem;
}
.visually-hidden:not(:focus):not(:active) {
    position: absolute;
    width: 1px;
    height: 1px;
    overflow: hidden;
    clip: rect(0 0 0 0);
    clip-path: inset(50%);
    white-space: nowrap;
}
```
</TabItem>
</Tabs>

## 🌃 Alternative Approach

지금까지의 파티클 애니메이션에서는 `top`과 `left`에 0%에서 100%까지 무작위 값을 선택하여 각 파티클을 무작위로 배치했습니다.

설정한 퍼센트 값은 '좋아요' 버튼, 다시말해 파티클의 컨테이너를 기준으로 합니다.

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <img
    src={require('./percentage-based-on-container.png').default}
    style={{ width: '50%' }}
  />
</div>

잘 동작하지만, 저에게는 자연스럽거나 직관적이지 않습니다. 이 설정은 파티클들이 버튼의 중심이 아니라 왼쪽 상단 모서리에서 나오는듯한 느낌을 줍니다.

그리고 백분율을 사용하는것이 꼭 좋은 선택인지는 모르겠습니다. 빠르고 쉽기 때문에 이 방법을 택했지만, 픽셀 단위를 사용하는 것이 좀더 직관적일 것 같습니다.
파티클은 중심에서 시작해야 하며 해당 위치에서 0px~50px 범위로 퍼져야 한다고 말할 수 있어야 합니다.

다시말해, 아래의 세팅이 좀더 자연스러울거 같습니다.

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <img
    src={require('./pixel-based-on-container.png').default}
    style={{ width: '50%' }}
  />
</div>

위 설정이 좀 더 나은 멘탈 모델이며, 코드도 좀더 간단하게 작성됩니다.

`top`과 `left`를 이용해 위치시키는것 대신에 `transform`을 사용해 리펙토링 해보겠습니다.

기본적인 전략은 다음과 같습니다. 추가적인 값 설정없이 모든 파티클들을 버튼에 중심에 위치시킵니다.
그런다음 `transform: translate()`을 사용하여 각각의 파티클들을 랜덤한 값만큼 이동시킵니다.

파티클들을 중심에 위치시키는 방법은 많지만 저는 'auto margin' 방법을 선호합니다.

```css
.centered {
  position: absolute;
  inset: 0;
  margin: auto;
  width: 12px;
  height: 12px;
}
```

만약 이 방식이 익숙하지 않다면, [How to Center a Div](https://www.joshwcomeau.com/css/center-a-div/#centering-with-positioned-layout-3)글에 더 자세한 정보가 있습니다.

이 방식은 파티클을 한 가운데에 위치시킵니다. 추가로 `transform: translate(-50%, -50%)` 속성도 제거 할 수 있습니다.
auto margin 방식은 transform 속성을 사용하지 않고도 요소를 가운데 위치시킬 수 있습니다.

처음에 구현했던 방식은, 각각의 파티클을 `0%`에서 `100%` 사이로 랜덤하게 배치되었습니다.
새로운 방법에서는 픽셀 단위의 양수또는 음수의 무작위 값을 사용합니다.

```js
const x = random(-48, 48);
const y = random(-48, 48);
particle.style.transform = `translate(${x}px, ${y}px)`;
```

이 방식이 제대로 동작하려면, keyframe 애니메이션을 수정해야 합니다.

```css
@keyframes fromCenter {
  from {
    transform: translate(0, 0);
  }
}
```

여기까지 작성한 코드는 정상적으로 동작하지만 한가지만 더 수정하겠습니다. 48이라는 값을 4번씩이나 반복하고 싶지 않기때문에 상수로 분리하겠습니다.

```js
const MAGNITUDE = 48;

btn.addEventListener('click', () => {
  // ...

  const x = random(-MAGNITUDE, MAGNITUDE);
  const y = random(-MAGNITUDE, MAGNITUDE);
});
```

최종 결과물은 아래와 같습니다.

<Tabs>
  <TabItem value="index.html" label="index.html">
    ```html 
    <style>
    @keyframes fadeToTransparent {
        to {
            opacity: 0;
        }
    }
    @keyframes fromCenter {
        from {
            transform: translate(0, 0);
        }
    }
    .particle {
        position: absolute;
        inset: 0;
        margin: auto;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: white;
        pointer-events: none;
        animation: fadeToTransparent var(--fade-duration) forwards, fromCenter 500ms;
    }
    </style>

    <button class="particleButton">
        <!-- 하트 svg -->
    </button>
    ```

  </TabItem>

<TabItem value="index.js" label="index.js">
```js
import { random, range } from 'lodash';
const btn = document.querySelector('.particleButton');
const FADE_DURATION = 1000;
const MAGNITUDE = 48;
btn.addEventListener('click', () => {
    btn.classList.toggle('liked');
    const isLiked = btn.classList.contains('liked');
    if (!isLiked) {
        return;
    }
    const particles = [];
    range(5).forEach(() => {
        const particle = document.createElement('span');
        particle.classList.add('particle');
        const x = random(-MAGNITUDE, MAGNITUDE);
        const y = random(-MAGNITUDE, MAGNITUDE);
        particle.style.transform = `translate(${x}px, ${y}px)`;
        particle.style.setProperty('--fade-duration', FADE_DURATION + 'ms');
        btn.appendChild(particle);
        particles.push(particle);
    });
    window.setTimeout(() => {
        particles.forEach((particle) => {
            particle.remove();
        });
    }, FADE_DURATION + 200);
});
```
</TabItem>
<TabItem value="index.css" label="index.css">
```css
html {
    --red: oklch(0.65 0.3 19.41);
}
body {
    display: grid;
    place-content: center;
    height: 100vh;
    background: hsl(210deg 15% 6%);
}
.particleButton {
    position: relative;
    padding: 16px;
    background: transparent;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    &:hover {
        background: hsl(0deg 0% 100% / 0.1);
        path {
            stroke: var(--red);
        }
    }
    &.liked path {
        fill: var(--red);
        stroke: var(--red);
    }
}
.particleButton svg {
    position: relative;
    display: block;
    width: 3rem;
    height: 3rem;
}
.visually-hidden:not(:focus):not(:active) {
    position: absolute;
    width: 1px;
    height: 1px;
    overflow: hidden;
    clip: rect(0 0 0 0);
    clip-path: inset(50%);
    white-space: nowrap;
}
```
</TabItem>
</Tabs>

## 🌃 Transform Benefits

앞의 예시에서 `top`, `left` 프로퍼티를 이용해 파티클들을 이동시키는것 대신에, `transform` 프로퍼티를 이용했습니다.

애니메이션에 있어 `transform`이 사실상 표준이라는 말을 들어본적이 있을 것 입니다. 애니메이션이 실행되는 동안, 브라우저는 초당 수십번 UI를 업데이트 해야합니다.
그리고 애니메이션의 부드러움은 매 프레임마다 필요한 작업량에 따라 달라집니다. `transform`은 CSS 속성 중에서도 최적화가 잘 되어 있어서, 브라우저가 이런 작업을 부담 없이 빠르게 처리할 수 있습니다.

하지만 이게 정말로 요즘에 문제가 될까요? 해당 부분에 대해 궁금증이 생겨 두 접근법에 대해 A/B 테스트를 진행했습니다. 파티클의 숫자를 점차 늘려가면서 어느 시점에 성능차이가 생기는지 확인해 보았습니다.

여러대의 기기로 테스트를 해보았고, 결과는 다음과 같습니다.

- 2024 M4 Max MacBook Pro에서는 파티클의 갯수가 610개까지 두 접근법의 성능차이가 없었지만, 그 이후부터는 "Top + Left" 방식이 약간 덜 부드럽게 동작했습니다.
- 낮은 성능의 윈도우 노트북에서는 223개부터 차이가 발생했습니다.
- 낮은 성능의 안드로이드 기기의 경우는 55개부터 차이가 발생했습니다.

이 결과는 조금 놀라웠는데, "Top + Left" 방식으로 50개 이상의 파티클들을 저사양 기기에서 처리할 수 있을거라고 생각하지 않았기 때문입니다.

사실, 수백개의 파티클을 처리할때 큰 문제가 하나 있습니다. 버튼을 클릭하고 파티클이 나타나기까지 지연이 있습니다. 이는 브라우저가 많은 수의 DOM 노드들 생성하는데 시간이 걸리기 때문입니다.
이 코스 후반부에, 2D Canvas가 어떻게 수백, 수천개의 요소들 동시에 움직이게 하는지를 살펴볼 것입니다.

그렇다고 해서 우리가 `transform`을 사용해야하는 이유가 단순히 성능 때문만은 아닙니다. 다른 중요한 이점이 있습니다.

## 🌃 Smoother motion

`transform`을 애니메이션에 사용하는 데에는 또 다른 중요하면서도 자주 논의되지 않는 이점이 있습니다.

잠시 주제를 바꿔 아래의 애니메이션을 살펴보겠습니다.

<Tabs>
  <TabItem value="index.html" label="index.html">
  ```html
  <style>
  a::after {
    content: '';
    height: 0px;
    transition: height 500ms;
  }
  a:hover::after {
    height: 2px;
  }
</style>

<nav>
    <a href="">Home</a>
    <a href="">About</a>
    <a href="">Contact</a>
</nav>
  ```
  </TabItem>
  <TabItem value="index.css" label="index.css">
  ```css
    html {
        height: 100vh;
        display: grid;
        place-content: center;
    }
    nav {
        display: flex;
        gap: 8px;
    }
    a {
        display: block;
        position: relative;
        padding: 8px 16px;
        color: black;
        text-decoration: none;
        &::after {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            background: hsl(250deg 100% 50%);
            transform-origin: bottom center;
        }
    }
```
</TabItem>
</Tabs>

이 애니메이션은 웹사이트에서 자주봤던 것입니다. 호버시에 파란색 선이 나타납니다.

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <video src={require('./navlinks-height.mp4').default} autoPlay loop muted />
</div>

이 애니메이션은 괜찮아 보이지만, 약간 층이 생기는것처럼 부자연스러워 보입니다. 완전히 부드럽게 동작하지 않습니다.
애니메이션 duration을 조금 늘려 확대해보면 애니메이션이 어떻게 동작하는지 정확히 볼 수 있습니다.

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <video
    width="70%"
    src={require('./zoomed-way-in-height.mp4').default}
    autoPlay
    loop
    muted
  />
</div>

이 애니메이션은 물리적인 제약을 받습니다. 픽셀은 디스플레이에서 가장 작은 단위이며 각 픽셀은 파란색이거나 파란색이 아닙니다. 즉 픽셀을 아래에서 위로 채우는 방식은 불가능합니다.

그런데, `height`대신에 `transform` 속성을 사용하여 애니메이션을 업데이트하면 어떤일이 일어나는지 확인해보세요.

<Tabs>
  <TabItem value="index.html" label="index.html">
    ```html
    <style>
        a::after {
            content: '';
            height: 2px;
            transform: scaleY(0);
            transition: transform 500ms;
        }
        a:hover::after {
            transform: scaleY(1);
        }
    </style>
    <nav>
        <a href="">Home</a>
        <a href="">About</a>
        <a href="">Contact</a>
    </nav>
    ```
  </TabItem>
  <TabItem value="index.css" label="index.css">
  ```css
  html {
    height: 100vh;
    display: grid;
    place-content: center;
  }
  nav {
    display: flex;
    gap: 8px;
  }
  a {
    display: block;
    position: relative;
    padding: 8px 16px;
    color: black;
    text-decoration: none;
  }
  &::after {
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    background: hsl(250deg 100% 50%);
    transform-origin: bottom center;
  }
  ```
  </TabItem>
</Tabs>

아래는 위 코드로 구현한 결과물 입니다.

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <video
    src={require('./navlinks-transform.mp4').default}
    autoPlay
    loop
    muted
  />
</div>

다시 한번, 속도를 낮추고 확대를해 어떻게 동작하는지 자세하게 살펴보겠습니다.

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <video
    width="70%"
    src={require('./zoomed-way-in-transform.mp4').default}
    autoPlay
    loop
    muted
  />
</div>

각 픽셀행은 투명한 상태에서 나타나고 있습니다. 이 방법은 놀라울 정도로 그럴듯한 착시 효과를 만들어내며, 마치 높이를 서브픽셀 단위로 애니메이션을 적용할 수 있는 것처럼 보입니다.

이를 때때로 서브픽셀 렌더링(sub-pixel rendering)이라고 하며, CSS `transform`만이 가진 강력한 기능입니다. 이 기능은 애니메이션을 좀더 유연하고 유기적으로 만듭니다.

아래은 두개의 구현 방식에 대한 결과를 비교한 것 입니다.

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <video
    width="70%"
    src={require('./height-vs-transform-slow.mp4').default}
    autoPlay
    loop
    muted
  />
</div>

제가 이 예시를 선택한 이유는 두 방법의 차이가 뚜렷하게 드러나기 때문입니다. 대부분의 경우 차이는 미미합니다.

우리가 만들고 있는 "좋아요" 버튼의 경우, 파티클들은 2px을 이동하는것이 아니라 최대 64px을 움직입니다. 다시말해 `transform`의 마법같은 기능이 동작할 기회가 거의 없습니다.
Apple Retina display에서는 차이가 거의 없었습니다.

하지만 기본적인 "1x" 디스플레이를 가진 저사양의 윈도우 노트북에서는 다른 이야기가 됩니다.
"Top + Left" 방식에서 파티클들은 움직임의 끝부분에서 계단 모양으로 나타나다가 갑자기 멈춘 후에 다른 픽셀로 이동합니다. 하지만 "Transforms" 모드에서는 움직임이 부드럽게 이어집니다.

결국 중요한것은 FPS만이 아닙니다. 최근에 나온 저사양의 하드웨어는 수십개의 파티클들을 프레임 드랍없이 처리할 수 있습니다.
대부분의 경우에서, CSS transform의 가장 큰 장점은 실제 픽셀 수보다 더 많은 픽셀을 가진 것처럼 보이게 만들어 디스플레이의 해상도가 높아진 듯한 착각을 준다는 점입니다.
이는 저사양의 디스플레이에서 애니메이션을 유연하고 유기적으로 만들어 줍니다.

:::tip Transform limitations
앞서 살펴봤듯이, `height`나 `top`/`left`를 사용하는것보다 CSS transform을 애니메이션에 사용하는것이 더 좋습니다.

하지만 transform을 사용하여 애니메이션을 구성하는것이 불가능한 경우가 있습니다. 만약 요소에 텍스트가 있는 경우, `transform: scale()`을 사용하여 요소의 넓이를 줄이려고 할때 텍스트가 뭉개집니다.

Transform은 여러단계를 생략하기 때문에 빠를 수 있습니다. `transform: scale`을 사용하여 리사이즈를 하는 경우, 브라우저는 요소를 평평한 텍스처로 간주하여 늘리거나 휘게 만듭니다.
`width`를 변경하는 것과 달리, 매 프레임마다 줄바꿈을 재계산하지 않습니다.

Transform을 무조건 사용해야 한다는 개발자들과 이야기를 나눠 본적이 있는데, CSS transform으로 애니메이션을 적용할 수 없는 경우, 그들은 `transition`을 제거하고 한 값에서 다른 값으로 즉시 전환되도록 한다고 합니다.
하지만 대부분의 경우, `width`처럼 비용이 비싼 프로퍼티에 애니메이션을 적용해도 됩니다.
:::

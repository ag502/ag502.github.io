---
slug: understanding-jsx
title: JSX 이해하기
tags: [react, learning-react]
unlisted: true
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

이 문서는 색인되지 않습니다.

{/* truncate */}

저번 글에서, 자바스크립트 객체를 사용하여 리액트 element가 어떻게 만들어지는지를 살펴봤습니다.

사실, 대부분의 개발자들은 element를 객체를 이용해 만들지 않습니다. JSX라 불리는 특별한 구분을 사용하는것이 더 일반적입니다.

아래는 앞서 살펴보았던 예제와 동일하지만, 자바스크립트 대신 JSX를 사용한 예제입니다.

```jsx
import React from 'react';
import { createRoot } from 'react-dom/client';

const element = <p id="hello">Hello World!</p>;

const container = document.querySelector('#root');
const root = createRoot(container);
root.render(element);
```

`React.createElement`를 사용하는것 대신에 React element를 생성하기 위해 HTML와 비슷한 구문을 사용했습니다.

왜 JSX를 사용할까요? 이런 작은 규모의 예시에서는 명확하게 드러나지 않을 수 있습니다만 마크업이 커지면 JSX가 읽기 쉽다는것이 분명해집니다.

React element도 HTML element와 마찬가지로 트리 구조를 형성할 수 있다는걸 기억하세요? React element의 "children" 프로퍼티에 다른 React element를 할당하면 트리구조가 형성됩니다.

실제로 React 코드에는 상당히 중요한 트리 구조가 포함되는 경우가 많습니다. 아래는 자바스크립트 객체를 이용한 예입니다.

```js
const element = React.createElement(
  'nav',
  { id: 'main-nav' },
  React.createElement(
    'ul',
    null,
    React.createElement(
      'li',
      null,
      React.createElement('a', { href: '/' }, 'Home'),
    ),
    React.createElement(
      'li',
      null,
      React.createElement('a', { href: '/archives' }, 'Archives'),
    ),
  ),
);
```

꽤 읽기 어렵습니다. 아래는 JSX를 사용한 동일한 예시입니다.

```jsx
const element = (
  <nav id="main-nav">
    <ul>
      <li>
        <a href="/">Home</a>
      </li>
      <li>
        <a href="/archives">Archives</a>
      </li>
    </ul>
  </nav>
);
```

이유가 무엇이든지, HTML과 비슷한 구문이 이해하기 훨씬 쉽습니다. 읽기도 쉽고, 쓰기도 쉽습니다.

## 🌃 JSX를 자바스크립트로 컴파일하기

만약 JSX 코드를 브라우저에서 실행시킨다면 오류가 발생할 것입니다. 자바스크립트 엔진은 JSX를 이해하지 못하고 자바스크립트만 이해할 수 있습니다. 따라서 코드를 자바스크립트 평문 코드로 "컴파일"할 필요가 있습니다.

이는 바벨과 같은 도구를 사용하여 빌드 단계에서 대부분 완료됩니다. 이 내용에 대해서는 나중에 살펴보겠습니다.

지금은 우리가 작성하는 JSX 코드가 `React.createElement`로 변환되어야 한다는 사실을 이해하는게 중요합니다. 코드가 사용자의 브라우저에서 실행되는 시점에 모든 JSX 코드는 사라지고, 중첩된 `React.createElement` 호출만 가득한 JS 파일만 남습니다.

:::info "transpiled" vs "compiled"
JSX를 브라우저 친화적인 자바스크립트로 변환하는 과정을 "compiling"이 아닌 "transpiling"이라고 부르기도 합니다. 두 용어는 동의어일까요? 아니면 무언가 다른걸까요?

둘은 다릅니다만 개인적으로 둘의 차이점은 크게 중요하지 않다고 생각합니다. 두 용어를 동의어로 처리해도 무방할듯합니다.

컴퓨터 과학에서 "compiling"은 보통 인간이 읽을 수 있는 코드를 기계가 이해할 수 있는 코드로 변환하는 것을 의미합니다.

예를 들어, 컴파일러는 파이썬과 같은 고수준의 언어를 기계가 이해할 수 있는 저수준 언어로 변경합니다.

반면 "transpiling"은 보통 하나의 고수준 언어를 다른 고수준의 언어로 변경하는것을 의미합니다. 예를 들어, 자바스크립트를 파이썬으로 "transpile" 할 수 있습니다.

따라서 엄격하게 용어를 적용해본다면, JSX -> JS 변환은 어떤 용어로 불려야 할까요?

글쎄요, 정하기가 어렵습니다. 브라우저는 JSX를 이해할 수 없습니다. 그러나 자바스크립트는 이해합니다. 그리고 JSX를 처리할 때는 기계에 더 친숙하게 처리합니다. 즉 사람이 읽기 어려워지고 기계는 읽기 쉬운 코드로 변환합니다.

반면에, 대부분의 리액트 개발자들은 변환된 자바스크립트 코드를 이해할 수 있습니다. 읽기 다소 어렵긴하지만, 아예 읽고 이해할 수 없을 정도는 아닙니다. 파이썬 개발자들이 기계어로 코드를 컴파일 할 때, 결과물로 나온 코드는 아예 이해할 수 없습니다.

위와 같은 이유로, 저는 "compile" 이라는 용어를 좀 더 선호합니다. 대부분은 "JSX를 자바스크립트로 컴파일 한다"의 의미를 이해할 것이고 그것이 가장 중요한 것입니다.
:::

:::warning 파일 확장자와 JSX
지금까지 살펴본 예제에서, 파일의 이름은 `index.js` 였습니다. 대부분의 사람들이 순수한 자바스크립트 파일이 아니기 때문에 파일이름을 `index.jsx`로 변경해야 하는게 아닌지 의문을 품습니다.

초창기 리액트에서는 JSX를 포함하는 파일은 반드시 `.jsx` 확장자를 명시해 줘야 했습니다. 이는 컴파일러에게 이 파일이 JSX 구문을 포함하고 있으니 자바스크립트 코드로 변경해야 한다고 알려주는 역할을 합니다.

이는 꽤 귀찮은 일입니다. 개발과정에서 신경써야 할 것이 하나 더 생기기 때문입니다. JSX를 추가하거나 제거할때마다 파일이름을 변경하는것은 너무 번거롭습니다.

그래서 이 규칙들은 느슨해졌습니다. 최근에는 `.js` 파일에서도 JSX 구문을 사용해도 문제없이 작동합니다. 컴파일러가 `.js` 파일은 JSX를 포함하고 있다고 가정합니다.
:::

## 🌃 React 임포트 구문 생략하기

아래의 코드를 살펴보겠습니다.

```jsx
import React from 'react';
import { createRoot } from 'react-dom/client';

const element = <p id="hello">Hello World!</p>;

const container = document.querySelector('#root');
const root = createRoot(container);
root.render(element);
```

첫줄에 `React`를 임포트 했습니다만, 실제로 사용하는 곳이 없습니다. 생략해도 되는걸까요?

사실 React 임포트를 사용하고 있습니다. 어떤 일이 일어나는지 살펴봅시다.

JSX 코드를 컴파일하면, 아래의 코드를 결과로 얻습니다.

```js
import React from 'react';
import { createRoot } from 'react-dom/client';

const element = React.createElement('p', { id: 'hello' }, 'Hello World!');

const container = document.querySelector('#root');
const root = createRoot(container);
root.render(element);
```

JSX가 자바스크립트 코드로 변환되면, 의존성이 명확해집니다. `<p>` 태그는 `React.createElement` 함수 호출로 변환 됩니다.

초기 리액트 버전에서는, React 임포트 구문을 생략한다면 아래와 같은 오류가 발생했습니다.

:::danger 오류
Error: React is not defined
:::

만약 `<p>`가 `React.createElement('p')`로 변환된다는것을 모르면, 위 오류메세지가 무엇을 의미하는지 어떻게 해결해야할지 모를것 입니다.

React 17버전 부터, 리액트팀은 바벨과 다른 컴파일러를 사용하여 새로운 "JSX transformer"를 도입했습니다. 빌드단계에서 임포트구문이 자동으로 주입됩니다.

아래의 코드를 예로 들어보겠습니다.

```jsx
const element = <p id="hello">Hello World!</p>;
```

최신 JSX transformer를 사용하면 아래와 같이 컴파일 됩니다.

```js
import { jsx as _jsx } from 'react/jsx-runtime';

const element = _jsx('p', { id: 'hello' }, 'Hello World!');
```

원본코드에서 어떠한 임포트 구문도 포함되지 않았다는것을 주목하세요. 컴파일러에의해 자동으로 포함됩니다.

`_jsx`는 `React.createElement`를 최적화한 것입니다. Fragments나 Portals을 사용할 때 더 빠르게 동작하는 기능이 포함되어 있습니다. 즉, `React.createElement`와 정확히 동일하게 동작합니다.

따라서 요즘에는 React를 직접 임포트할 필요가 없습니다. JSX 컴파일러가 이를 대신 해결해 줍니다.

## 🌃 표현식 슬롯

JSX에서 태그 사이에 추가한 컨텐츠는 정적인 문자로 취급됩니다. 만약 변수를 참조하려고 한다면, 참조의 값이 아니라 변수의 이름이 출력됩니다.

```jsx
import React from 'react';
import { createRoot } from 'react-dom/client';

const shoppingList = ['apple', 'banana', 'cherry'];

const element = <div>Item left to purchase: shoppingList.length</div>;
```

위와 같이 `shoppingList.length`라는 변수를 참조하려고 한다면, 3이라는 값이 아니라 `shoppingList.length`라는 문자열이 출력됩니다. JSX코드가 컴파일될 때 아래와 같이 변환되기 때문입니다.

```js
const element = React.createElement(
  'div',
  {},
  'Item left to purchase: shoppingList.length',
);
```

중괄호를 사용해서 표현식 슬롯을 만들수 있고, 그 사이에 위치한 것들은 문자열이 아닌 순수한 자바스크립트로 취급됩니다. 중괄호는 컴파일될 때 또다른 자식으로 변환되기 때문입니다.

```jsx
const element = <div>Item left to purchase: {shoppingList.length}</div>;
```

```js
const element = React.createElement(
  'div',
  {},
  'Item left to purchase: ',
  shoppingList.length,
);
```

JSX가 `React.createElement` 함수 호출로 변환이 되고 중괄호 사이에 위치한 것들은 함수의 인자이기 때문에, 문(statement)를 넣으면 오류가 발생합니다. 중괄호 사이에는 반드시 표현식이 들어가야 합니다.

### 🎆 JSX에서의 주석

JSX에서 주석을 추가할때도, 표현식 슬롯을 사용합니다.

```jsx
const element = <div>{/* Some comment! */}</div>;
```

한줄 주석(//)을 사용하지 않고 여러줄 주석(/\* \*/)을 사용해야 합니다. 한줄 주석은 `}` 괄호를 포함해서 모든 것을 주석 처리하기 때문입니다.

```
const element = (
  <div>
    {// Some comment!}
  </div>
)
```

### 🎆 속성 표현식 슬롯

동적인 속성 값에도 동일하게 적용할 수 있습니다.

```jsx
const uniqueId = 'content-wrapper';

const element = <main id={uniqueId}>Hello World</main>;
```

위에서 보았듯이 중괄호로 표현식 슬롯을 만들 수 있습니다. 이제, `id` 속성을 위한 슬롯을 만들어 보겠습니다.

아래는 컴파일 되는 방식입니다.

```js
const element = React.createElement(
  'main',
  {
    id: uniqueId,
  },
  'Hello World',
);
```

비교를 위해 표현식 슬롯이 없고 id값이 고정된 경우는 아래와 같이 컴파일 됩니다.

```js
const element = <main id="content-wrapper">Hello World</main>;

const compiledElement = React.createElement(
  'main',
  { id: 'content-wrapper' },
  'Hello World',
);
```

속성값을 동적으로 설정하고 싶을 때 표현식 슬롯을 사용할 수 있습니다. 단순 값 뿐만 아니라 유효한 자바스크립트 표현식을 넣을 수 있습니다.

```js
const userEmail = 'sumeet@thegreat.com';

const element = <main id={userEmail.replace('@', '-')}>Hello World</main>;

const compiledElement = React.createElement(
  'main',
  {
    id: userEmail.replace('@', '-'),
  },
  'Hello World',
);
```

컴파일될 때, 코드가 평가되지 않는다는 점을 명심하세요. 위 코드에서 `useEmail` 문자열에서 `@`을 `-`로 변경하여 `sumeet-thegreat.com` 문자열을 생성하는 로직을 작성했지만 코드가 실행될 때 동작합니다.

JSX가 자바스크립트로 컴파일될 때, 중괄호 사이에 있는 모든것은 그대로 복사가 됩니다. 어떠한 함수도 호출되거나 실행되지 않습니다. 함수의 호출은 오직 브라우저에서 자바스크립트가 실행될 때 이루어집니다.

이는 컴파일 타임(코드가 브라우저에서 실행되기전 발생하는 코드 처리)과 런타임(코드가 브라우저에서 실행되는 시점)의 차이점입니다.

#### 🎇 타입 강제

런타임에서, 리액트는 표현식 슬롯에 속성을 제공할 때 필요에 따라 타입을 자동으로 변환합니다.

예를 들어, 아래의 두 element는 동일합니다.

```jsx
<input required="true" />
```

```jsx
<input required={true} />
```

첫번째 예시에서는, `required` 속성에 `"true"` 문자열을 할당하고 있습니다. 두 번째 예시에서는 boolean 타입인 `true`를 할당했습니다. HTML에서 값은 반드시 문자열이여야 합니다. 따라서 `true`는 `"true"`로 변환됩니다.

비슷하게, 숫자나 문자를 숫자 타입 속성에 할당할 수 있습니다.

```jsx
<input type="range" min="1" max="20" />
```

```jsx
<input type="range" min={1} max={20} />
```

:::info Boolean 속성
HTML에서 속성키 만을 사용하여 값을 `true`로 설정할 수 있습니다.

```html
<input required />
```

이 패턴은 JSX에서도 동일합니다. 아래의 두 예시는 동일합니다.

```jsx
<input required />
```

```jsx
<input required={true} />
```

:::

## 🌃 HTML과의 차이점

JSX는 HTML과 비슷하지만 근본적인 차이가 있습니다. 그 차이를 살펴보겠습니다.

### 🎆 예약어

자바스크립트에는 여러개의 예약어가 존재합니다. 예약어는 고유한 기능을 가지고 있는 키워드 입니다. 이미 사용되고 있기 때문에 JSX에서는 사용할 수 없습니다.

예를 들어 `const while = 10;` 와 같은 코드는 오류가 발생합니다. `while`이라는 예약어가 자바스크립트의 반복문에서 사용되고 있기 때문입니다.

```js
let count = 6;

while (count > 0) {
  console.log('Countdown:', count);
  count--;
}
```

JSX는 자바스크립트로 변환되기 때문에 JSX에서 예약어를 사용할 수 없습니다. 이것이 문제가 되는 이유는 HTML 속성중에 자바스크립트의 예약어와 겹치는 속성이 있기 때문입니다.

```js
/* eslint-disable */
const element = (
  <div>
    <label for="name">Name:</label>
    <input id="name" class="fun-input" />
  </div>
);
```

위 코드를 자바스크립트로 변환하게 되면, 두개의 예약어를 사용하고 있음을 알게됩니다.

- `for`
- `class`

이러한 충돌을 해결하기 위해 리액트는 두개의 예약어에 약간의 변형을 줬습니다.

```js
const element = (
  <div>
    <label htmlFor="name">Name:</label>
    <input id="name" className="fun-input" />
  </div>
);
```

- `for` -> `htmlFor`
- `class` -> `className`

:::info 정상적으로 동작하긴 합니다. 하지만...
JSX에서 `for`나 `class`를 사용하면 리액트 프레임워크가 경고를 노출하지만 오류는 발생하지 않습니다. 사실 정상 동작합니다.

특정 상황에서는 예약어에 대한 충돌이 발생하지 않습니다. 하지만 문제가 발생하는 상황이 존재하기 때문에 `for`나 `class`를 사용하면 안됩니다.

조금 더 깊게 들어가보면, `for`와 `class`는 HTML 요소에 사용하는 경우 정상적으로 동작합니다. 하지만 커스텀 컴포넌트에서 사용할 경우 문제가 발생합니다.
:::

### 🎆 Self-closing 태그

HTML은 상당히 느슨한 언어입니다. 예를 들어, 아래의 HTML 코드는 정상적인 코드입니다.

```html
<!-- prettier-ignore -->
<div>
  <p>This paragraph is opened… but never closed.
  <p>We're omitting the closing tags!
</div>
```

Paragraph 태그는 중첩되지 않습니다. 브라우저는 두번째 paragraph가 시작하기전에 첫번째 paragraph가 닫힌다는걸 알정도로 똑똑하기 때문에,
자동으로 `</p>` 태그를 추가합니다. 자바스크립트 엔진이 생략된 세미콜론을 자동으로 추가해주는 것과 비슷합니다.

JSX는 다릅니다. 열린 태그는 반드시 닫아야 합니다.

```js
const element = (
  <div>
    <p>This paragraph is opened… but never closed.</p>
    <p>We are omitting the closing tags!</p>
  </div>
);
```

HTML5에서 특정 요소는 닫는 태그가 없습니다. 예를 들어, `img` 태그는 자식을 가질 수 없고 닫을 필요도 없습니다.

```html
<!-- prettier-ignore -->
<img src="https://example.com/image.png" alt="An image" >
```

JSX에서는 명시적으로 태그를 닫아줘야 합니다. "self-closing" 태그를 이용해서 명시적으로 닫을 수 있습니다.

```js
const element = <img src="https://example.com/image.png" alt="An image" />;
```

(self-closing 태그는 예전 버전의 HTML에서 유래했습니다. 현대의 HTML에서 필수적이지 않지만 여전히 유효합니다.)

### 🎆 Case-sensitive 태그

HTML은 case-insensitive한 언어입니다. 수년전에는 HTML을 모두 대문자로 쓰는것이 보편적이였습니다.

```html
<!-- prettier-ignore -->
<MAIN>
  <HEADER>
    <H1>Hello World!</H1>
  </HEADER>
  <P>
    This HTML is so loud!
  </P>
</MAIN>
```

반대로, JSX는 case-sensitive한 언어입니다. 태그는 반드시 소문자로 작성해야 합니다.

```js
const element = (
  <main>
    <header>
      <h1>Hello World!</h1>
    </header>
    <p>This HTML is so loud!</p>
  </main>
);
```

이 제한은 다소 자의적으로 보이지만, 여기에 매우 중요한 이유가 있습니다.
JSX 컴파일러는 태그의 대소문자 사용 여부를 통해 해당 요소가 HTML 태그인지 커스텀 컴포넌트인지를 구별합니다.

### 🎆 Case-sensitive 속성

JSX에서 속성은 camelCase로 작성해야 합니다.

예를 들어, 아래는 유효한 HTML입니다.

```html
<video src="https://example.com/video.mp4" autoplay="true />
```

JSX에서는 "autoplay"의 글자 "p"를 대문자로 작성해야 합니다. "auto"와 "play"는 분리된 단어이기 때문입니다.

```js
const element = <video src="https://example.com/video.mp4" autoPlay={true} />;
```

(`true`를 문자열로 유지하는 대신 표현식 슬롯을 이용하여 `{true}`로 작성했습니다. 둘 다 유효한 방식이지만 표현식 슬롯이 좀 더 리액트에 맞는 방식입니다.)

속성이 복수개의 단어로 이루어져 있는지 판단하는 것은 어렵습니다. 특히나 모국어가 영어가 아니라면 더더욱 어렵습니다.
다행이도 만약 실수를 했다면 개발자 도구에 경고문이 노출됩니다.

```js
/* eslint-disable */
const element = (
  <video
    src="https://sandpack-bundler.vercel.app/videos/cat-skateboarding.mp4"
    autoplay={true}
  />
);
```

:::warning
Invalid DOM property 'autoplay'. Did you mean 'autoPlay'?
:::

camelCase로 작성되어야 하는 다른 속성은 아래와 같습니다.

- `onclick` -> `onClick`
- `tabindex` -> `tabIndex`
- `stroke-dasharray` -> `strokeDasharray`

:::warning Data와 ARIA 속성은 dash를 유지합니다.
Data 속성과 ARIA 속성은 camelCase의 규칙을 따르지 않습니다.

아래은 유효한 JSX 코드입니다.

```js
const element = (
  <button data-test-id="close-dialog-button" aria-label="Close dialog">
    <img alt="" src="/icons/x.svg" />
  </button>
);
```

Data 속성은 리액트에서 자주 사용되지는 않습니다만, 자동화된 테스트에서 요소에 라벨을 붙일 때 유용합니다.
ARIA 속성은 접근성 요소를 추가할 때 사용됩니다.
:::

### 🎆 인라인 스타일

HTML에서 style 속성은 지정된 요소에 스타일을 직접 지정할 수 있습니다.

```html
<h1 style="font-size: 2rem;">Hello World!</h1>
```

JSX에서 `style`은 객체를 받습니다.

```js
const element = <h1 style={{ fontSize: '2rem' }}>Hello World!</h1>;
```

:::info 이중 중괄호??
이중 중괄호를 사용하는게 조금 이상할 수 있습니다. 왜 아래와 같이 쓰면 안될까요?

```text
const element = (
  <h1  style={fontSize: '2rem'}>
    Hello World!
  </h1>
)
```

앞 글에서 살펴봤듯이 자바스크립트 표현식을 JSX에 삽입하기위해 중괄호를 사용했습니다. 예를 들어, 아래와 같이 중괄호를 사용할 수 있습니다.

```js
const avatarSrc = '/image/avatar.png';

const element = <img alt="user avatar" src={avatarSrc} />;
```

스타일을 적용하려면 설정하려는 CSS 속성과 해당값을 담은 객체를 전달해야 합니다.

```js
const customStyles = {
  fontSize: '2rem',
  fontWeight: 'bold',
};

const element = <h1 style={customStyles}>Hello World!</h1>;
```

이 스타일들을 가지고 있는 변수를 생성하기보다는, 객체 자체를 JSX 표현식 슬롯에 바로 넣습니다.

```jsx
const element = (
  <h1
    style={{
      fontSize: '2rem',
      fontWeight: 'bold',
    }}
  >
    Hello World!
  </h1>
);
```

두가지의 중괄호가 필요합니다.

1. JSX에서 자바스크립트 표현식을 삽입하기 위한 표현식 슬롯
2. CSS 선언을 위한 객체

:::

모든 CSS 속성은 "camelCase"로 작성됩니다. 모든 dash는 다음 단어의 대문자로 변경됩니다.

- `background-position` -> `backgroundPosition`
- `border-bottom-color` -> `borderBottomColor`

`-webkit-font-smoothing`과 같은 vendor prefix는 `WebkitFontSmoothing`처럼 첫글자를 대문자로 변경합니다.

또한 리액트는 특정 CSS 속성에 `px`을 자동으로 붙여줍니다.

```js
<div style={{ width: 200, paddingTop: 8 }}></div>
```

`flex`나 `lineHeight`와 같이 단위가 없는 속성을 주의하세요.

예를 들어, 아래의 코드는 20px의 높이가 아니라 기본값보다 20배 큰 라인 높이를 의미합니다.

```jsx
<p
  style={{
    lineHeight: 20, // line-height: 20
  }}
></p>
```

리액트에서는 단위가 없는 값을 사용하는것이 관례이지만, 원한다면 단위를 사용해도 됩니다.

```js
<p style={{ width: '200px', paddingTop: '8px' }}></p>
```

:::인라인 스타일이 나쁜가?
인라인 스타일을 사용하지 말라는 것을 들어본적이 있을겁니다. 이것들은 `!important`와 같이 특수한 상황에서 최후의 수단으로만 사용해야 합니다.

개인적으로, 스타일의 주요 수단으로 인라인 스타일을 쓰지말아야 하는것은 동의하지만, 인라인 스타일이 더 나은 선택인 경우도 있습니다.
:::

## 🌃 공백관련 주의사항

JSX에서 가장 흔한 함정중의 하나를 살펴보겠습니다.

```js
import { createRoot } from 'react-dom/client';

const daysUntilSantaReturns = 123;

const element = (
  <div>
    <strong>Days until Santa returns:</strong>
    {daysUntilSantaReturns}
  </div>
);

const container = document.querySelector('#root');
const root = createRoot(container);
root.render(element);
```

굵은 글씨와 숫자 사이에 공백이 없는것을 눈치채셨나요? `returns: 123`이 아니라 `return:123`이 출력됩니다.

왜 이런 현상이 발생하는지를 알려면, 어떻게 이 JSX가 자바스크립트로 변환되는지를 살펴보아야 합니다.

```js
const element = React.createElement(
  'div',
  {},
  React.createElement('strong', {}, 'Days until Santa returns:'),
  daysUntilSantaReturns,
);
```

`div` 태그는 `strong` 태그와 `daysUntilSantaReturns` 변수를 자식으로 가집니다.

JSX는 HTML로 컴파일되는것이 아니라, 자바스크립트로 컴파일된다는 것을 명심하세요. 그리고 해당 자바스크립트가 실행될 때는 두 개의 HTML노드가 생성되고 추가됩니다.

- 텍스트를 가진 `<strong>` 태그
- `123`의 값을 가진 텍스트 노드

그래서 이를 어떻게 고치면 좋을까요? 가장 흔한 방법은 단일 공백을 중괄호에 추가하는 것입니다.

```js
// prettier-ignore
<div>
  <strong>Days until Santa returns:</strong>
  {' '}
  {daysUntilSantaReturns }
</div>
```

위 코드는 아래와 같이 컴파일됩니다.

```js
const element = React.createElement(
  'div',
  {},
  React.createElement('strong', {}, 'Days until Santa returns: '),
  ' ',
  daysUntilSantaReturns,
);
```

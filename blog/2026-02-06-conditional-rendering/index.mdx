---
slug: conditional-rendering
title: 조건부 렌더링
tags: [react]
unlisted: true
---

이 문서는 색인되지 않습니다.

{/* truncate */}

리액트에서 조건에 따라 마크업 코드를 렌더링해야하는 상황이 자주 발생합니다. 현재 온라인인 상태의 친구 이름 옆에 초록색 점을 노출하는 경우가 그 예입니다.

## 🌃 If 문으로 조건부 렌더링하기

JSX에서 중괄호를 사용하여 표현식을 추가했습니다. 하지만 안타깝게도 선언문은 추가할 수 없습니다.
따라서, 아래의 코드는 올바르지 않습니다.

```
function Friend({ name, isOnline }) {
  return (
  <li className="friend">
    {if (isOnline) {
        <div className="green-dot" />
    }}

    {name}
  </li>
  );
}
```

왜 이 코드는 동작하지 않을까요? 자바스크립트로 컴파일된 결과로 살펴보겠습니다.

```
function Friend({name, isOnline}) {
    return React.createElement(
        "li",
        {className: "friend"},
        if (isOnline) {
            React.createElement("div", {className: "green-dot"});
        },
        name
    )
}
```

문제는 `if` 문을 함수 호출 중간에 넣을 수 없다는 것입니다. 더 간단하게 비유를 하자면 아래와 같이 실행하려는 것과 동일합니다.

```
console.log(
    if (isLoggedIn) {
        "Logged in!"
    } else {
        "Not logged in"
    }
)
```

그렇지만 `if` 문을 사용할 수 있습니다! 대신 `React.createElement` 함수 호출의 중간에 들어가지 않도록 위로 끌어올려야 합니다.

```jsx
function Friend({ name, isOnline }) {
  let prefix;

  if (isOnline) {
    prefix = <div className="green-dot" />;
  }

  return (
    <li className="friend">
      {prefix}
      {name}
    </li>
  );
}
```

JSX가 반드시 `return` 문의 일부분이여야 한다는 규칙은 없습니다. JSX 코드는 컴포넌트 안이라면 어디서든 변수에 할당할 수 있습니다.

위 코드는 다음과 같이 컴파일 됩니다.

```js
function Friend({ name, isOnline }) {
  let prefix;

  if (isOnline) {
    prefix = React.createElement('div', { className: 'green-dot' });
  }

  return React.createElement('li', { className: 'friend' }, prefix, name);
}
```

위 코드에서 `prefix` 변수는 리액트 요소를 할당받거나 아예 정의되지 않을 수 있습니다. 정의되지 않은 값에 대해서는 리액트가 무시하기 때문에 신경쓰지 않아도 됩니다.

:::info 정의되지 않은 속성
아래의 코드를 살펴보겠습니다.

```jsx
function Greeting() {
  let someClass;

  return <div className={someClass}>Hello World</div>;
}
```

마크업이 어떻게 보일까요?

아래의 HTML이 생성됩니다.

```html
<div>Hello World</div>
```

위 코드에서 `someClass` 변수는 생성되었지만 값이 할당되진 않았습니다. 즉, `undefined` 입니다.

리액트가 `undefined`로 설정된 속성은 DOM 노드에서 완전히 생략합니다. `className=""`와 같은 빈 값을 주는 대신, 값이 설정되지 않은 것처럼 동작합니다.

이 동작은 `null` 과 `false` 같은 falsy 값에서도 동일합니다.
:::

## 🌃 &&로 조건부 렌더링하기

`if`문을 사용하는 방법의 단점은 마크업과 떨어진 위치에 로직을 위치시켜야 한다는 점입니다.
이 방법은 유효한 방법이지만, 컴포넌트의 구조를 파악하기 어렵습니다. 특히나 컴포넌트가 복잡하다면 더욱 그렇습니다. 무엇을 반환했는지 알려면 코드의 이곳 저곳을 돌아다녀야 합니다.

다행히도, `if` 로직을 JSX 코드 내에 위치시킬 수 있는 방법이 있습니다. 바로 `&&` 연산자를 사용하는 방법입니다.

어떻게 하는지 살펴보겠습니다.

```jsx
function Friend({ name, isOnline }) {
  return (
    <li className="friend">
      {isOnline && <div className="green-dot" />}
      {name}
    </li>
  );
}
```

자바스크립트에서 `&&`는 흐름제어 연산자입니다. 문이아니라 식이라는것만 제외하면 if/else와 동일합니다.

실제로 어떤일이 일어나는지 알아보기 위해 같은 로직을 `if/else`문을 사용하여 작성해보겠습니다.

```jsx
function Friend({ name, isOnline }) {
  let prefix;

  if (isOnline) {
    prefix = <div className="green-dot" />;
  } else {
    prefix = isOnline;
  }

  return (
    <li className="friend">
      {prefix}
      {name}
    </li>
  );
}
```

`&&` 연산자는 `if/else`문 처럼 두가지 경우중 한가지를 취한다는 점에서 흐름 제어 연산자로 볼 수 있습니다.

만약 연산자 왼쪽의 값이 falsy 하다면, 표현식은 short-circuit 연산을 수행하고 `isOnline` 값을 `false`로 평가합니다.
그렇지 않다면, 연산자의 오른쪽에 있는 값으로 평가됩니다. (`<div className="green-dot" />`)

### 🎆 많이 실수하는 부분: 숫자 0

아래의 상황을 살펴보겠습니다.

```jsx
function App() {
  const shoppingList = ['avocado', 'banana', 'cinnamon'];
  const numOfItems = shoppingList.length;

  return <div>{numOfItems && <ShoppingList items={shoppingList} />}</div>;
}
```

`ShoppingList` 컴포넌트는 shopping list의 아이템 갯수가 1개 이상일때만 렌더링되어야 합니다.

자바스크립트를 꽤 오랬동안 사용해왔다면 0을 제외한 모든 숫자들은 truthy 하다는 것을 알것입니다. 0은 `''`과 마찬가지로 falsy한 값입니다.

따라서 `numOfItems`가 최소 1개 이상이면 값은 truthy가 되고, `ShoppingList` 요소를 렌더링해야 하고 만약 0개의 아이템이 있다면 건너 뛰어야 합니다.

하지만 실제 결과는 그렇지 않습니다. 숫자 0이 렌더링됩니다!

왜 이런 결과가 일어날까요? 두가지를 명심해야 합니다.

1. `&&` 연산자는 `true`나 `false`를 반환하지 않습니다. 이 연산자는 왼쪽이나 오른쪽 값 중 하나를 반환합니다. 따라서, 요소가 비어 있다면 이 표현식은 `0`으로 평가됩니다.

2. 리액트는 그 어떤 숫자도 모두 렌더링합니다.

리액트는 `false`나 `null`과 같은 falsy 값은 무시하지만 숫자 0은 무시하지 않습니다.

실제로, 리액트가 어떻게 falsy 한 값을 처리하는지 살펴보겠습니다.

```jsx live
function FalsyValues() {
  return (
    <div>
      <p>false: [{false}]</p>
      <p>null: [{null}]</p>
      <p>undefined: [{undefined}]</p>
      <p>0: [{0}]</p>
      <p>빈 문자열: [{``}]</p>
      <p>NaN: [{NaN}]</p>
    </div>
  );
}
```

리액트는 숫자 `0`을 렌더링 했습니다. 생각해보면 이는 당연합니다. 숫자 0을 사용해야하는 상황은 매우 많습니다.

#### 🎇 해결책: &&연산자를 사용할 때는 항상 boolean 값을 사용하세요

애플리케이션에 임의의 `0` 문자가 섞이는 것을 방지하려면, `&&` 연산자의 왼쪽이 항상 boolean 값으로 평가되게 해야합니다.

예를 들어, 숫자가 0보다 큰지 아닌지를 확인하면 됩니다.

```jsx
function App() {
  const shoppingList = ['avocado', 'banana', 'cinnamon'];
  const numOfItems = shoppingList.length;

  return <div>{numOfItems > 0 && <ShoppingList items={shoppingList} />}</div>;
}
```

저는 이 방법을 좋아합니다. 조건이 무엇인지 구체적으로 설명하고 있습니다. 만약 shopping list의 아이템이 1개 이상이면, `<ShoppingList>` 요소를 렌더링 합니다.
`>` 연산자는 항상 boolean 값을 반환합니다.

또다른 방법으로는 `!!` 연산자를 사용하여 boolean이 아닌값을 boolean으로 변환하는 방법입니다.

```jsx
function App() {
  const shoppingList = ['avocado', 'banana', 'cinnamon'];
  const numOfItems = shoppingList.length;

  return <div>{!!numOfItems && <ShoppingList items={shoppingList} />}</div>;
}
```

:::info ESLint 규칙
표현식이 `0`이나 `NaN`로 렌더링될 가능성이 있다면 경고를 노출하는 ESLint 규칙이 있습니다. [jsx-not-leaked-render](https://github.com/jsx-eslint/eslint-plugin-react/blob/master/docs/rules/jsx-no-leaked-render.md) 입니다.
:::

## 🌃 삼항 연산자로 조건부 렌더링하기

`&&` 연산자를 사용하면 특정 조건이 충족될 경우 조건부 렌더링을 할 수 있습니다. 하지만 조건이 충족되지 않을 경우 다른 것을 렌더링하고 싶다면 어떻게 해야 할까요?

관리자용 대시보드를 만들고 있다고 가정해보겠습니다. 만약 사용자가 로그인했다면, 차트와 테이블을 포함한 모든 요소를 렌더링하지만 그렇지 않다면 로그인하라는 짧은 메세지를 렌더링해야 합니다.

두개의 `&&` 연산자로 이를 구현할 수 있습니다.

```jsx
function App({ user }) {
  const isLoggedIn = !!user;

  return (
    <>
      {isLoggedIn && <AdminDashboard />}
      {!isLoggedIn && <p>Please log in</p>}
    </>
  );
}
```

위 코드는 동작하지만 다소 투박합니다. 다행이도 삼항 연산자를 사용하면 더 간단하게 작성할 수 있습니다.

삼항 연산자를 사용한 코드는 다음과 같습니다.

```jsx
function App({ user }) {
  const isLoggedIn = !!user;

  return <>{isLoggedIn ? <AdminDashboard /> : <p>Please log in</p>}</>;
}
```

이 연산자는 리액트에 있어 굉장히 유용합니다. JSX에 if/else 로직을 추가할 수 있기 때문입니다.
삼항 연산자는 문이 아니라 연산자이기 때문에 자바스크립트 표현식 내에서 사용할 수 있습니다.

삼항연산자는 세부분으로 구성되어 있습니다.

> 조건 ? 첫번째 표현식 : 두번째 표현식

만약 조건이 참이라면, 첫번째 표현식이 평가되고 거짓이라면 두번째 표현식이 평가됩니다.

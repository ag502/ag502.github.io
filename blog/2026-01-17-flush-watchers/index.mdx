---
slug: flush-watchers
title: Flush Watchers
tags: [vue, vue-reactivity]
unlisted: true
---

이 문서는 색인되지 않습니다.
{/* truncate */}

Watcher에서 DOM을 조작할 때 타이밍은 매우 중요한 문제입니다.
기본적으로, watcher는 DOM이 업데이트되기 전에 실행이 되는데 이는 새롭게 렌더링된 요소에 접근하려할 때 문제가 됩니다.

## 🌃 Watcher의 실행 타이밍에 대한 문제점

새로 추가된 아이템에 대해 자동으로 스크롤이 되는 리스트를 예시로 들어보겠습니다.

```html
<template>
  <div>
    <button @click="addItem">Add item</button>

    <ul ref="list" class="item-list">
      <li v-for="(item, i) in items" :key="i">{{ item}}</li>
    </ul>
  </div>
</template>

<script setup>
  import { ref, watch, useTemplateRef } from 'vue';

  const items = ref([
    'Item 1',
    'Item 2',
    'Item 3',
    'Item 4',
    'Item 5',
    'Item 6',
  ]);
  const listEl = useTemplateRef('list');

  function addItem() {
    items.value.push(`Item ${items.value.length + 1}`);
  }

  watch(
    items,
    () => {
      const last = listEl.value?.lastElementChild;
      last?.scrollIntoView({ behavior: 'smooth', block: 'center' });
    },
    { deep: true },
  );
</script>
```

"Add Item" 버튼을 클릭하면, data가 변경되자마자 watcher가 실행됩니다. 하지만 DOM은 아직 업데이트되지 않았습니다.
`lastElementChild`는 새로 추가된 요소가 아닌 마지막에서 두번째 요소를 가르키게 됩니다. 따라서 scroll 동작은 의도한대로 동작하지 않습니다.

## 🌃 Flush Timing 옵션 이해하기

Vue는 세가지 flush timing 옵션을 제공합니다.

`pre` flush는 DOM이 업데이트되기 전에 실행되며 기본값입니다. 이 옵션은 반응형 상태를 업데이트하는 대부분의 경우에 잘 동작합니다.

`post` flush는 DOM 업데이트가 완료된 후에 실행됩니다. 이 옵션은 업데이트된 DOM요소의 수치를 계산하거나 접근하기 위해 사용하는 옵션입니다.

`sync` flush는 반응형 데이터가 변경되자마자 즉시 실행되는 옵션입니다. 이 옵션은 Vue의 배치 시스템을 우회하기 때문에 성능에 악영향을 미칠 수 있습니다. 따라서 신중하게 사용해야 합니다.

## 🌃 Post Flush Timing

Watcher의 실행시점을 변경하려면 `flush` 옵션을 사용해야 합니다.

```html
<script setup>
  import { watch } from 'vue';
  // 생략
  watch(
    items,
    () => {
      const last = listEl.value?.lastElementChild;
      last?.scrollIntoView({ behavior: 'smooth', block: 'center' });
    },
    {
      flush: 'post',
      deep: true,
    },
  );
</script>
```

`flush`에 `post`를 설정하면 watcher는 DOM 업데이트가 완료되기를 기다렸다가 실행됩니다. 따라서 `lastElementChild`는 새롭게 추가된 아이템을 올바르게 가르킵니다.

### 🎆 내부에서 일어나는 일어나는 일

"Add Item" 버튼을 클릭했을 때 내부에서 일어나는 일을 살펴보겠습니다.

- 'post' flush 적용 전
  1. 아이템이 배열에 추가됨
  2. Watcher가 실행됨
  3. `lastElementChild`는 "Item 6"을 가르킴(마지막 요소의 직전 아이템)
  4. 잘못된 요소로 스크롤 됨

- 'post' flush 적용 전
  1. 아이템이 배열에 추가됨
  2. DOM이 업데이트 됨
  3. DOM 업데이트후에 watcher가 실행됨
  4. `lastElementChild`는 "Item 7"을 가르킴(새롭게 추가된 아이템)
  5. 올바른 요소로 스크롤 됨

Post flush timing은 항상 watcher가 업데이트된 DOM상태에 접근할 수 있게 합니다.

## 🌃 Sync Flush Timing

Vue는 성능 향상을 위해 watcher의 업데이트를 배치 처리합니다. 하지만 때때로 같은 틱 내에서 여러개의 변경 사항이 발생하더라도 모든 중간 값을 캡처할 필요가 있습니다.

이런 경우에 sync flush watcher가 유용합니다.

### 🎆 기본적인 배치 동작

빠르게 여러번 업데이트되는 카운터를 예시로 들어보겠습니다.

```html
<template>
  <div>
    <button @click="updateMultipleTimes">Update 5 Times</button>

    <p>Current Value: {{ count }}</p>
    <p>Watcher Executions: {{ watcherExecutions }}</p>
    <p>History: {{ history.join(', ') }}</p>
  </div>
</template>

<script setup>
  import { ref, watch } from 'vue';

  const count = ref(0);
  const watcherExecutions = ref(0);
  const history = ref([]);

  function updateMultipleTimes() {
    for (let i = 0; i < 5; i++) {
      count.value += 1;
    }
  }

  watch(count, (newValue) => {
    watcherExecutions.value++;
    history.value.push(newValue);
    console.log(`Watcher fired: ${newValue}`);
  });
</script>
```

버튼을 클릭하면, 카운트는 0부터 5까지 하나의 틱에서 증가합니다. 하지만 watcher는 단 한번만 실행됩니다.

위 코드를 실행하면 아래와 같은 결과가 출력됩니다.

```
Current Value: 5
Watcher Executions: 1
History: 5
```

중간값들(1, 2, 3, 4)는 Vue의 배치로 인해 무시됩니다.

### 🎆 즉각적인 업데이트를 위해 sync flush 사용하기

모든 중간값을 캡처하기 위해소는 `flush: sync` 옵션을 사용할 수 있습니다.

```html
<script setup>
  watch(
    count,
    (newValue) => {
      watcherExecutions.value++;
      history.value.push(newValue);
      console.log(`Watcher fired: ${newValue}`);
    },
    {
      flush: 'sync',
    },
  );
</script>
```

위 코드를 실행하면 아래와 같이 출력됩니다.

```
Current Value: 5
Watcher Executions: 5
History: 1, 2, 3, 4, 5
```

Watcher는 모든 변경에 대해 즉시 실행되며 모든 중간값들도 캡처됩니다.

### 🎆 Sync Flush를 사용해야 하는 경우

Sync watcher는 모든 중간값들을 순서대로 캡처하기 때문에 로깅, 분석 또는 상태 기록 추적에 사용될 수 있습니다.

Sync watcher는 DOM 업데이트에 의존하지 않습니다. DOM이 업데이트되기 전에 실행되기 때문에 업데이트된 DOM요소에 접근할 수 없습니다.

Sync watcher는 Vue의 배치 최적화를 우회하기 때문에 성능에 악영향을 미칠수는 있습니다.

---
slug: flush-watchers
title: Flush Watchers
tags: [vue, vue-reactivity]
unlisted: true
---

이 문서는 색인되지 않습니다.
{/* truncate */}

Watcher에서 DOM을 조작할 때 타이밍은 매우 중요한 문제입니다.
기본적으로, watcher는 DOM이 업데이트되기 전에 실행이 되는데 이는 새롭게 렌더링된 요소에 접근하려할 때 문제가 됩니다.

## 🌃 Watcher의 실행 타이밍에 대한 문제점

새로 추가된 아이템에 대해 자동으로 스크롤이 되는 리스트를 예시로 들어보겠습니다.

```html
<template>
  <div>
    <button @click="addItem">Add item</button>

    <ul ref="list" class="item-list">
      <li v-for="(item, i) in items" :key="i">{{ item}}</li>
    </ul>
  </div>
</template>

<script setup>
  import { ref, watch, useTemplateRef } from 'vue';

  const items = ref([
    'Item 1',
    'Item 2',
    'Item 3',
    'Item 4',
    'Item 5',
    'Item 6',
  ]);
  const listEl = useTemplateRef('list');

  function addItem() {
    items.value.push(`Item ${items.value.length + 1}`);
  }

  watch(
    items,
    () => {
      const last = listEl.value?.lastElementChild;
      last?.scrollIntoView({ behavior: 'smooth', block: 'center' });
    },
    { deep: true },
  );
</script>
```

"Add Item" 버튼을 클릭하면, data가 변경되자마자 watcher가 실행됩니다. 하지만 DOM은 아직 업데이트되지 않았습니다.
`lastElementChild`는 새로 추가된 요소가 아닌 마지막에서 두번째 요소를 가르키게 됩니다. 따라서 scroll 동작은 의도한대로 동작하지 않습니다.

## 🌃 Flush Timing 옵션 이해하기

Vue는 세가지 flush timing 옵션을 제공합니다.

`pre` flush는 DOM이 업데이트되기 전에 실행되며 기본값입니다. 이 옵션은 반응형 상태를 업데이트하는 대부분의 경우에 잘 동작합니다.

`post` flush는 DOM 업데이트가 완료된 후에 실행됩니다. 이 옵션은 업데이트된 DOM요소의 수치를 계산하거나 접근하기 위해 사용하는 옵션입니다.

`sync` flush는 반응형 데이터가 변경되자마자 즉시 실행되는 옵션입니다. 이 옵션은 Vue의 배치 시스템을 우회하기 때문에 성능에 악영향을 미칠 수 있습니다. 따라서 신중하게 사용해야 합니다.

## 🌃 Post Flush Timing

Watcher의 실행시점을 변경하려면 `flush` 옵션을 사용해야 합니다.

```html
<script setup>
  import { watch } from 'vue';
  // 생략
  watch(
    items,
    () => {
      const last = listEl.value?.lastElementChild;
      last?.scrollIntoView({ behavior: 'smooth', block: 'center' });
    },
    {
      flush: 'post',
      deep: true,
    },
  );
</script>
```

`flush`에 `post`를 설정하면 watcher는 DOM 업데이트가 완료되기를 기다렸다가 실행됩니다. 따라서 `lastElementChild`는 새롭게 추가된 아이템을 올바르게 가르킵니다.

### 🎆 내부에서 일어나는 일어나는 일

"Add Item" 버튼을 클릭했을 때 내부에서 일어나는 일을 살펴보겠습니다.

- 'post' flush 적용 전
  1. 아이템이 배열에 추가됨
  2. Watcher가 실행됨
  3. `lastElementChild`는 "Item 6"을 가르킴(마지막 요소의 직전 아이템)
  4. 잘못된 요소로 스크롤 됨

- 'post' flush 적용 전
  1. 아이템이 배열에 추가됨
  2. DOM이 업데이트 됨
  3. DOM 업데이트후에 watcher가 실행됨
  4. `lastElementChild`는 "Item 7"을 가르킴(새롭게 추가된 아이템)
  5. 올바른 요소로 스크롤 됨

Post flush timing은 항상 watcher가 업데이트된 DOM상태에 접근할 수 있게 합니다.

---
slug: getting-started-with-react-hooks
title: React Hook 시작하기
tags: [secret-react, learning-react]
unlisted: true
---

이 문서는 색인되지 않습니다.

{/* truncate */}

## 🌃 컴포넌트의 한계와 Hook의 등장

예전에는 컴포넌트가 유일한 도구였습니다. 리액트에서 해결해야하는 모든 문제는 컴포넌트로 풀어야 했습니다.

물론 컴포넌트는 정말 훌륭합니다. 마크업, 스타일, 로직을 하나의 재사용 가능한 번들로 묶을 수 있다는 건 정말 멋진 일입니다. 하지만 모든 문제를 컴포넌트로 풀 수는 없습니다.

대표적인 예가 애니메이션입니다. 유명한 애니메이션 라이브러이인 react-motion은 _render props_ 라는 패턴을 사용합니다. 해당 패턴은 아래와 같습니다.

```jsx
import { Motion, spring } from 'react-motion';

class App extends React.Component {
  render() {
    return (
      <Motion defaultStyle={{ opacity: 0 }} style={{ opacity: sprint(1) }}>
        {({ opacity }) => <div style={{ opacity }}>This div fades in</div>}
      </Motion>
    );
  }
}
```

왜 `Motion` 컴포넌트는 children으로 함수를 전달했을까요?

사실, 이 방법은 컴포넌트를 data 처리기로 사용하는 방법입니다. UI를 직접 생성하는것 대신에, 값을 생성합니다.
특정 시점의 opacity를 넘겨주면 props로 넘겨주면 현재 시점의 opacity를 계산해줍니다.

애니메이션 뿐만이 아닙니다. 컴포넌트가 유일한 수단이였기 때문에 다음과 같은 다양한 용도로 사용해야 했습니다.

1. 데이터 불러오기
2. 네트워크 요청
3. 페이지가 마운트 되었을 때 스크롤 맨위로 올리기
4. 컴포넌트 레이지 로딩

UI를 생성하지 않는 모든 사용 예시들은 _Wrapper Hell_ 이라는 문제를 야기했습니다.

<img src={require('./wrapper-hell.png').default} />

이 문제를 해결하기 위해서 리액트 팀은 새로운 도구를 만들었습니다. 바로 hook 입니다.

이미 앞에서 `useState`를 사용하여 리액트의 상태에 연결("hook into")하는 것을 보았습니다.

```jsx
function Button({ children }) {
  const [hi, setHi] = React.useState(5);

  function handleClick(event) {
    console.log('Clicked!');
    setHi(hi + 1);
  }

  return <button onClick={handleClick}>{children}</button>;
}
```

Hook의 가장 큰 장점은 비즈니스 로직을 묶어 재사용할 수 있게 한다는 것입니다.
`Button` 컴포넌트를 애플리케이션 곳곳에 배치할 수 있는 것처럼, `useMousePosition`이나 `useSpringAnimation` 같은 비즈니스 로직을 묶어 컴포넌트 간에 공유할 수 있습니다.

<details>
<summary>섹션 요약</summary>

- 과거에는 컴포넌트가 리액트의 유일한 도구였기 때문에, UI 생성 외의 로직(애니메이션, 데이터 불러오기 등)도 컴포넌트로 해결해야 했습니다.
- 이로 인해 render props 같은 패턴이 등장했고, _Wrapper Hell_ 문제가 발생했습니다.
- 리액트 팀은 이 문제를 해결하기 위해 **Hook**이라는 새로운 도구를 만들었습니다.
- Hook을 사용하면 비즈니스 로직을 컴포넌트와 분리하여 재사용할 수 있습니다.

</details>

## 🌃 useId Hook

리액트의 핵심 아이디어는 컴포넌트의 재사용 입니다. 여러개의 컴포넌트를 오류없이 렌더링할 수 있어야 합니다.

하지만 웹의 특정 부분은 재사용을 고려하지 않고 설계되었습니다. 예를 들어, `id` 속성은 전역적으로 고유해야 합니다!
어떻게 이 규칙을 지켜 재사용 가능한 컴포넌트를 생성할까요?

사실, `id`와 같은 새로운 prop을 추가할 수도 있습니다. 이렇게 하면 개발자는 각 인스턴스에 대해 고유한 값을 지정할 수 있습니다.

이 방법은 그럴싸해 보이지만, 전역적으로 고유한 값을 전달하려면 개발자의 기억력에 의존해야 한다는 문제가 있습니다.

다행히도 리액트 팀은 `useId`라는 hook을 제공합니다. 컴포넌트 내부에서 아래와 같이 사용하면 됩니다.

```jsx
function LoginForm() {
  const id = React.useId();
}
```

이 컴포넌트의 각각의 인스턴스는 모두 다른 값을 가지게 됩니다.
예를 들어, 만약 2개의 인스턴스를 렌더링한다면 첫번째 `id  변수는 `:r0:`가 되고 두번째는 `:r1`이 됩니다.

리액트 hook은 컴포넌트 인스턴스에 연결("hook into")됩니다. 따라서 ID는 인스턴스에 존재하며 렌더링될 때 꺼내올 수 있습니다.

다시 말해, 값은 렌더링간에 유지되며 첫번째로 렌더링되는 `id` 값은 항상 `:r0:` 입니다.

<details>
<summary>섹션 요약</summary>

- 웹의 `id` 속성은 전역적으로 고유해야 하므로, 재사용 가능한 컴포넌트에서 `id`를 직접 지정하면 충돌 위험이 있습니다.
- `useId` hook은 각 컴포넌트 인스턴스마다 고유한 ID(`:r0:`, `:r1:` 등)를 자동으로 생성해줍니다.
- hook은 컴포넌트 인스턴스에 연결되므로, 생성된 ID는 렌더링 간에 유지됩니다.

</details>

## 🌃 Hook의 규칙

지금까지 hook이 리액트 내부와 연결해주는 특별한 함수라는것을 살펴보았습니다. 예를 들어, `useState`는 컴포넌트 인스턴스의 상태에 연결("hook into")할 수 있게 해주고, `useId`는 컴포넌트 인스턴스에 고유한 식별자를 생성하고 저장할 수 있게 해줍니다.

만약 이 함수들을 리액트 컨텍스트 밖에서 호출하면 어떻게 될까요?

```jsx
import React from 'react';

try {
  React.useId();
} catch (error) {
  //
}
```

위와 같이 작성하면 린트 오류와 함께 콘솔에 오류가 출력됩니다.

:::danger
Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:

1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app

:::

콘솔의 오류는 심각한 오류가 발생했다고 알립니다. 그리고 3개의 가능성을 제시합니다. 1, 3번 오류는 거의 발생하지 않는 오류입니다. 하지만 2번째 오류는 흥미롭습니다.
"Rules of Hooks"가 뭘까요?

우선 hook은 일반적인 자바스크립트 함수라는걸 이해해야 합니다. 생각만큼 마법은 아닙니다.

하지만 이 함수는 호출될 때, 리액트 내부와 연결됩니다. 그렇기 때문에 잘못 사용하면 예기치 못한 오류가 발생할 수 있습니다.
이 함수는 특정한 방법으로 사용되도록 설계되었고 만약 규칙을 어긴다면 오류가 발생합니다.

리액트가 의도한대로 hook을 사용하려면 두가지 "Rules of Hooks" 규칙을 준수해야 합니다.

1. Hook은 리액트 애플리케이션 내부에서 호출되어야 합니다. 즉, 리액트 컴포넌트 밖에서 호출할 수 없습니다.
2. Hook은 반드시 컴포넌트 최상단에서만 호출되어야 합니다.

두 번째 규칙이 많은 사람들이 헷갈려 하는 부분입니다. 좀 더 자세히 살펴보겠습니다.

아래의 코드가 있다고 가정해보겠습니다.

```jsx
function TextInput({ id, label, type }) {
  let appliedId = id;

  if (typeof appliedId === 'undefined') {
    appliedId = React.useId();
  }

  return (
    <div className="text-input">
      <label htmlFor={appliedId}>{label}</label>
      <input id={appliedId} type={type} />
    </div>
  );
}
```

`TextInput` 컴포넌트는 `id` prop을 옵셔널로 받습니다. 만약 값이 없다면 자동으로 생성합니다.

위 코드는 정상적으로 작성된 코드처럼 보이지만 hook의 규칙 중 하나를 어겼습니다.

규칙에 따르면 조건부로 hook을 사용할 수 없습니다. `if` 조건문이나 `switch` 문, `for` 문, 콜백 안에서 hook을 사용할 수 없습니다.

이 규칙이 존재하는 이유를 설명하려면 복잡한 과정을 거쳐야 하는데, 지금은 간단히만 살펴보겠습니다.

두 개의 상태가 있는 컴포넌트를 생각해보겠습니다.

```jsx
function TextInput({ id, label, type }) {
  const [x, setX] = React.useState(0);
  const [y, setY] = React.useState(0);
}
```

두개의 상태가 필요해 `useState`를 두번 호출했습니다.

여기서 한가지 의문이 듭니다. 리액트는 우리가 요청하는 상태가 어떤 상태인지 어떻게 알 수 있을까요?

잘보면 우리는 상태에 고유한 ID를 넘긴적이 없습니다.

```js
const [x, setX] = React.useState({ id: 'x' });
const [y, setY] = React.useState({ id: 'y' });
```

:::info
리렌더링이 일어나면 컴포넌트 함수가 처음부터 다시 실행되기 때문에, React는 각 useState 호출에 이전에 저장해둔 상태 중 어떤 값을 돌려줘야 하는지 알아야 합니다. 그런데 ID를 넘기지 않는다면, 어떻게 구분하는 걸까요?
:::

리액트는 값을 hook에 전달하기 위해 함수 호출의 순서를 이용합니다.

만약 컴포넌트가 100번 렌더링된다면, 정확히 같은 hook들을 정확히 같은 순서로 호출해야 합니다.
만약 hook을 조건부로 호출한다면 렌더링간에 호출되는 hook들이 달라질 수 있습니다.

이렇게 되면 `y` 변수가 `x` 변수에 할당될 수 있습니다.

이 규칙은 `useState` 뿐만이 아니라 모든 hook에 적용됩니다.

따라서 처음 살펴보았던 코드는 아래와 같이 수정할 수 있습니다.

```jsx
function TextInput({ id, label, type }) {
  const generatedId = React.useId();
  const appliedId = id || generatedId;

  return (
    <div className="text-input">
      <label htmlFor={appliedId}>{label}</label>
      <input id={appliedId} type={type} />
    </div>
  );
}
```

수정된 버전에서는 ID의 제공 여부와 관계없이 `React.useId`를 항상 호출하고 있습니다.

ID가 필요없는 상황에서도 값을 생성하는게 불필요한 작업일 수 있다고 생각될 수 있지만, 다행히도 이 작업은 매우 빠르게 실행됩니다.
따라서 성능에 미치는 영향은 없습니다.

<details>
<summary>섹션 요약</summary>

- Hook은 리액트 내부와 연결되는 특별한 함수이므로, 두 가지 "Rules of Hooks" 규칙을 지켜야 합니다.
- **규칙 1**: Hook은 리액트 컴포넌트 내부에서만 호출해야 합니다.
- **규칙 2**: Hook은 컴포넌트 최상단에서만 호출해야 합니다. 조건문, 반복문, 콜백 안에서 호출할 수 없습니다.
- 리액트는 hook의 호출 순서로 각 상태를 구분하기 때문에, 조건부 호출 시 순서가 뒤섞여 버그가 발생합니다.

</details>

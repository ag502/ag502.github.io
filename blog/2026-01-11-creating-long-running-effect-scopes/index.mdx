---
slug: creating-long-running-effect-scopes
title: ìˆ˜ëª…ì´ ê¸´ Effect Scope ë§Œë“¤ê¸°
tags: [secret-vue, vue-reactivity]
unlisted: true
---

ì´ ë¬¸ì„œëŠ” ìƒ‰ì¸ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
{/* truncate */}

ì»´í¬ë„ŒíŠ¸ë³´ë‹¤ ì˜¤ë˜ ìœ ì§€ë˜ëŠ” effect scopeë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ scopeëŠ” ì»´í¬ë„ŒíŠ¸ ë°–ì—ì„œ ìœ ì§€ë©ë‹ˆë‹¤.

ì´ ê¸€ì—ì„œëŠ” `useStore` composableì„ ë§Œë“¤ì–´ ì»´í¬ë„ŒíŠ¸ë¼ë¦¬ ë°ì´í„°ë¥¼ ê³µìœ í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ ë³´ê² ìŠµë‹ˆë‹¤.

## ğŸŒƒ ë¬¸ì œì 

Store composableì˜ ë‹¨ìˆœí•œ êµ¬í˜„ë¶€í„° ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

```js
import { ref, watch, effectScope } from '@vue/reactivity';

export function useStore() {
  const count = ref(0);

  watch(count, (v) => console.log('watch', v));

  return { count };
}
```

ìœ„ ì˜ˆì‹œëŠ” ë°˜ì‘í˜• `count`ì™€ `count`ê°’ì´ ë³€ê²½ë  ë•Œ ë¡œê·¸ê°€ ì¶œë ¥ë˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ storeë¥¼ ë³µìˆ˜ì˜ ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©í•œë‹¤ë©´ ì–´ë–»ê²Œ ë ê¹Œìš”?

ì•„ë˜ëŠ” ë‘ê°œì˜ ë‹¤ë¥¸ ì»´í¬ë„ŒíŠ¸ì— ì‚¬ìš©í–ˆì„ ë•Œì˜ ë°ëª¨ì…ë‹ˆë‹¤.

```js
function runDemo() {
  let storeA, storeB;

  const componentA = effectScope();
  componentA.run(() => {
    console.log('Component A: Getting store and setting count to 5');

    storeA = useStore();
    storeA.count.value = 5;

    console.log(`Component A: count is ${storeA.count.value}`);
  });

  const componentB = effectScope();
  componentB.run(() => {
    console.log('Component B: Getting store (should be same as Component A)');

    storeB = useStore();
    console.log(`Component B: count is ${storeB.count.value}`);

    console.log('Component B: Setting count to 10');
    storeB.count.value = 10;
  });

  // Component A storeëŠ” Component Bì™€ ë¶„ë¦¬ë˜ì–´ ìˆìŒ
  componentA.run(() => {
    console.log(`Component A: count is ${storeA.count.value}`);
  });
}
```

Component AëŠ” ë…ìì ì¸ effect scopeë¥¼ ìƒì„±í•˜ê³  `useStore`ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤. ìƒì„±ëœ storeëŠ” countê°’ì„ 5ë¡œ ì„¤ì •í•˜ê³  ê°’ì„ ì¶œë ¥í•©ë‹ˆë‹¤.

Component Bë„ ë¹„ìŠ·í•œ ë™ì‘ì„ í•©ë‹ˆë‹¤. Component Aê°€ ìƒì„±í•œ storeì™€ ë™ì¼í•œ storeê°€ ìƒì„±ë˜ê¸¸ ê¸°ëŒ€í•˜ë©´ì„œ `useStore`ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ê·¸ë ‡ì§€ ì•ŠìŠµë‹ˆë‹¤.

## ğŸŒƒ ì‹¤ì œë¡œ ì¼ì–´ë‚˜ëŠ” ì¼ì–´ë‚˜ëŠ” ì¼

ìœ„ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë©´, ê°ê°ì˜ ì»´í¬ë„ŒíŠ¸ëŠ” ë¶„ë¦¬ëœ storeë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

```
Component A: Getting store and setting count to 5
watch 5
Component A: count is 5
Component B: Getting store (should be same as Component A)
Component B: count is 0
Component B: Setting count to 10
watch 10
Component A: count is 5 (expected 10)
```

Component AëŠ” countê°’ì„ 5ë¡œ ì„¤ì •í–ˆê³  watcherëŠ” 5ë¥¼ ì¶œë ¥í–ˆìŠµë‹ˆë‹¤.

í•˜ì§€ë§Œ Component Bê°€ storeì— ì ‘ê·¼í•´ countë¥¼ ì¶œë ¥í•˜ë©´ 0ì´ ì¶œë ¥ë©ë‹ˆë‹¤. ê¸°ì¡´ì˜ ë™ì¼í•œ ê°’ì„ ì°¸ì¡°í•œê²Œ ì•„ë‹ˆë¼ ìƒˆë¡œìš´ data storeë¥¼ ìƒì„±í–ˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

Component BëŠ” count ê°’ì„ 10ìœ¼ë¡œ ì„¤ì •í•˜ë©´ watcherê°€ ì‹¤í–‰ë©ë‹ˆë‹¤. ì´ëŠ” ë‘ê°œì˜ storeê°€ ë…ë¦½ì ì„ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

Component Aì˜ count ê°’ì€ ì—¬ì „íˆ 5 ì…ë‹ˆë‹¤.

## ğŸŒƒ í•´ê²°ì±…

ì»´í¬ë„ŒíŠ¸ê°€ ë™ì¼í•œ ê°’ì„ ê³µìœ í•  ìˆ˜ ìˆë„ë¡ `useStore`ë¥¼ ìˆ˜ì •í•´ë³´ê² ìŠµë‹ˆë‹¤.

cache ê°’ì„ í•¨ìˆ˜ ë°–, ëª¨ë“ˆ ë‚´ë¶€ì— ì„¤ì •í•©ë‹ˆë‹¤.

```js
import { ref, watch, effectScope } from '@vue/reactivity';

// ì»´í¬ë„ŒíŠ¸ê°€ storeë¥¼ ê³µìœ í•  ìˆ˜ ìˆë„ë¡ cache
let cached;

export function useStore() {
  if (!cached) {
    const count = ref(0);
    watch(count, (v) => console.log('watch', v));

    cached = { count };
  }

  return cached;
}
```

ìƒˆë¡œìš´ ë°˜ì‘í˜• ìƒíƒœë¥¼ ë§¤ë²ˆ ìƒì„±í•˜ëŠ”ê²Œ ì•„ë‹ˆë¼ ìºì‹œëœ ê°’ì´ ìˆëŠ”ì§€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤. ë§Œì•½ ìºì‹œëœ ê°’ì´ ì—†ë‹¤ë©´ ë°˜ì‘í˜• ìƒíƒœë¥¼ ìƒì„±í•˜ê³  ì´ ê°’ì„ cacheì— í• ë‹¹í•©ë‹ˆë‹¤.

## ğŸŒƒ ë˜ë‹¤ë¥¸ ë¬¸ì œ: Watcher ê³µìœ 

ìºì‹œëœ ìƒíƒœ ê°’ì´ ë‘ê°œì˜ ì»´í¬ë„ŒíŠ¸ì— ê³µìœ ë˜ê³  ìˆì§€ë§Œ, watcherë„ ì»´í¬ë„ŒíŠ¸ë¼ë¦¬ ê³µìœ ë˜ê³  ìˆìŠµë‹ˆë‹¤.
í•˜ì§€ë§Œ effect scope ë™ì‘ ë°©ì‹ ë•Œë¬¸ì— ìºì‹œëœ ì»´í¬ë„ŒíŠ¸ê°€ ì—†ì„ ë•Œ, `useStore`ë¥¼ í˜¸ì¶œí•˜ëŠ” ìµœì´ˆì˜ ì»´í¬ë„ŒíŠ¸ì— watcherê°€ ì—°ê²°ë©ë‹ˆë‹¤.

ë§Œì•½ ìµœì´ˆì˜ ì»´í¬ë„ŒíŠ¸ê°€ unmount ë˜ë©´ watcherë„ í•¨ê»˜ ì •ë¦¬ë©ë‹ˆë‹¤. ì´ëŠ” storeì— ì˜ì¡´ì„±ì´ ìˆëŠ” ì»´í¬ë„ŒíŠ¸ê°€ ìˆë”ë¼ë„ ë°œìƒí•©ë‹ˆë‹¤.

```js
function runDemo() {
  // Component 1 lifecycle
  console.log('=== Component 1 mounts ===');
  const component1Scope = effectScope();
  let store1;
  component1Scope.run(() => {
    store1 = useStore();
    console.log('Component 1 gets store and creates watcher');
    store1.count.value = 1;
  });

  // Component 2 lifecycle
  console.log('\n=== Component 2 mounts ===');
  const component2Scope = effectScope();
  let store2;
  component2Scope.run(() => {
    store2 = useStore();
    console.log('Component 2 gets same store (no new watcher created)');
    store2.count.value = 2;
  });

  console.log('Both components share the same state:');
  console.log('store1 === store2:', store1 === store2);

  // Component 1 unmounts
  console.log('\n=== Component 1 unmounts ===');
  component1Scope.stop();
  console.log('Component 1 scope stopped - watcher is destroyed');

  // Component 2ì—ì„œ store ê°’ ì—…ë°ì´íŠ¸
  console.log('\n=== Component 2 tries to update count ===');
  store2.count.value = 3;
  console.log("Notice: No 'watch 3' log! The watcher is gone.");
}
```

ì²«ë²ˆì§¸ë¡œ, Component 1ì˜ effect scopeë¥¼ ìƒì„±í–ˆìŠµë‹ˆë‹¤. ë‚´ë¶€ì—ì„œ `useStore`ë¥¼ í˜¸ì¶œí•˜ê³  ê°’ì„ 1ë¡œ ì„¤ì •í–ˆìŠµë‹ˆë‹¤.
ê·¸ ë‹¤ìŒì— Component 2ì˜ effect scopeë¥¼ ìƒì„±í•œ í›„ storeë¥¼ ê°€ì ¸ì™€ í•´ë‹¹ ê°’ì„ 2ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.

Storeì˜ ë™ì¼ì„±ì„ í™•ì¸í•˜ëŠ” ë¡œê·¸ë¥¼ í†µí•´ ë‘ê°œì˜ storeê°€ ë™ì¼í•œê²ƒì„ì„ ì¦ëª…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ê·¸ëŸ° ë‹¤ìŒ `component1Scope.stop()`ë¥¼ í˜¸ì¶œí•¨ìœ¼ë¡œì¨ Component 1ì˜ unmountë¥¼ ì¬í˜„í–ˆìŠµë‹ˆë‹¤.

Component 2ê°€ ê°’ì„ ì—…ë°ì´íŠ¸ í•  ë•Œ ì„±ê³µì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ ë˜ì§€ë§Œ watcherëŠ” ë” ì´ìƒ ì‹¤í–‰ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

## ğŸŒƒ ì‹¤ì œë¡œ ì¼ì–´ë‚˜ëŠ” ì¼

ìœ„ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë©´ ì•„ë˜ì™€ ê°™ì€ ê²°ê³¼ê°€ ì¶œë ¥ë©ë‹ˆë‹¤.

```
Component 1 gets store and create watcher
watch 1
Component 2 gets same store (no new watcher created)
watch 2
Both components share the same state: true
Component 1 unmounts
Component 2 tries to update count
Notice: No 'watch 3' log! The watcher is gone.
```

Component 1ì€ countë¥¼ 1ë¡œ ì„¤ì •í•˜ê³  ì´ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤. Component 2ëŠ” ê°’ì„ 2ë¡œ ì„¤ì •í•˜ê³  ì´ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.
í•˜ì§€ë§Œ Component 1ê°€ unmount ëœ í›„ì— Component 2ì˜ countë¥¼ ì—…ë°ì´íŠ¸ í•˜ë©´ "watch 3"ëŠ” ì¶œë ¥ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Component 1ì´ unmountë  ë•Œ watcherë„ ì‚¬ë¼ì§€ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

## ğŸŒƒ í•´ê²°ì±…: createSharedComposable

`useStore`ë¥¼ `createSharedComposable` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤. ì´ êµ¬í˜„ì€ VueUseì˜ `createSharedComposable`ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•©ë‹ˆë‹¤.

```js
function createSharedComposable(fn) {
  let scope, cached;

  return (...args) => {
    if (!scope) {
      // detached scope
      scope = effectScope(true);

      // detached scopeë‚´ì—ì„œ composable ì‹¤í–‰
      cached = scope.run(() => fn(...args));
    }

    return cached;
  };
}
```

ìœ„ ì½”ë“œì—ì„œëŠ” ë‘ê°€ì§€ë¥¼ ìºì‹±í•©ë‹ˆë‹¤. ì²«ë²ˆì§¸ëŠ” ì‹¤ì œ storeì´ê³  ë‘ë²ˆì§¸ëŠ” effect scope ì…ë‹ˆë‹¤.

Detached scopeì„ ìƒì„±í•˜ê¸° ìœ„í•´ `effectScope(true)`ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤. ì´ scopeëŠ” ì–´ë–¤ ì»´í¬ë„ŒíŠ¸ì—ë„ ì¢…ì†ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

ê·¸ëŸ°ë‹¤ìŒ ì „ë‹¬ëœ í•¨ìˆ˜ë¥¼ ê°€ì ¸ì™€ ìƒì„±í•œ scope ë‚´ë¶€ì—ì„œ ì‹¤í–‰í•©ë‹ˆë‹¤. ë‚˜ë¨¸ì§€ ì—°ì‚°ìë¥¼ ì‚¬ìš©í•´ ì¸ìˆ˜ë¥¼ ê°€ì ¸ì™€ í•¨ìˆ˜ì— ì „ë‹¬í•©ë‹ˆë‹¤.

ì´ í•¨ìˆ˜ê°€ ë°˜í™˜í•˜ëŠ” ê°’ì€ `scope.run()` í•¨ìˆ˜ í˜¸ì¶œì´ ë°˜í™˜í•œ ê°’ì…ë‹ˆë‹¤. ì´ ê°’ì€ ìºì‹œëœ ê°’ì´ ë©ë‹ˆë‹¤. ì´ ë¡œì§ì€ scopeê°€ ì—†ëŠ” ê²½ìš°ì—ë§Œ ì‹¤í–‰ë˜ë„ë¡ í•©ë‹ˆë‹¤.

## ğŸŒƒ createSharedComposable ì‚¬ìš©í•˜ê¸°

`useStore` ì½”ë“œë¥¼ ìƒˆë¡­ê²Œ ê³ ì³ë³´ê² ìŠµë‹ˆë‹¤.

```js
const useStore = createSharedComposable(() => {
  const count = ref(0);
  watch(count, (v) => console.log('watch', v));
  return { count };
});
```

ì´ í•¨ìˆ˜ê°€ ì‹¤í–‰ë  ë•Œë§ˆë‹¤ ìºì‹œëœ ê°’ì´ ë°˜í™˜ë©ë‹ˆë‹¤.

## ğŸŒƒ ê²°ê³¼

ìœ„ ì½”ë“œë¥¼ ì‹¤í–‰ì‹œí‚¤ë©´ ì•„ë˜ì™€ ê°™ì€ ê²°ê³¼ê°€ ë‚˜ì˜µë‹ˆë‹¤.

```
=== Component 1 mounts ===
Component 1 gets store and creates detached watcher
watch 1

=== Component 2 mounts ===
Component 2 gets same store (watcher in detached scope)
watch 2

Both components share the same state: true

=== Component 1 unmounts ===
Component 1 scope stopped - but watcher is in detached scope!

=== Component 2 tries to update count ===
watch 3
Success! We see "watch 3" because watcher is detached.
```

## ğŸŒƒ createSharedComposableì˜ ë¬¸ì œì 

`createSharedComposable`ì„ ì‚¬ìš©í•˜ë©´ íŠ¹ì • ì»´í¬ë„ŒíŠ¸ì— effectë“¤ì´ ê³ ì •ë˜ëŠ” ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆì§€ë§Œ, effect scopeì´ ì¤‘ì§€ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

ì´ composableì„ ì‚¬ìš©í•˜ê³  ìˆëŠ” ì»´í¬ë„ŒíŠ¸ë“¤ì´ë‚˜ effect scopeë“¤ì„ ì¶”ì í•´ì•¼ í•©ë‹ˆë‹¤. ë§ˆì§€ë§‰ ì»´í¬ë„ŒíŠ¸ë‚˜ effect scopeì—ì„œ ì‚¬ìš©ì´ ëë‚˜ë©´ í•´ë‹¹ scopeë¥¼ ì¤‘ì§€í•´ì•¼í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

ì•„ë˜ ì½”ë“œì—ì„œ ë¬¸ì œë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

```js
function runDemo() {
  let storeReference = null;

  // ë³¸ì¸ì˜ scopeì—ì„œ storeë¥¼ ì‚¬ìš©í•˜ê³  ìˆëŠ” component
  console.log('Simulating component mounting and using store:');
  const componentScope = effectScope();
  componentScope.run(() => {
    console.log('Component using store:');
    const componentStore = useStore();
    componentStore.count.value++;
    storeReference = componentStore;
  });

  console.log('Store created and used - watcher should be active');

  // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸
  console.log('\nSimulating component unmounting:');
  componentScope.stop();
  console.log('Component scope stopped');

  console.log('\nTesting if detached scope was automatically cleaned up:');
  storeReference.count.value++;
  console.log(
    'If you see "watch 2" above, the detached scope was NOT cleaned up!',
  );
}
```

ìœ„ ì½”ë“œëŠ” ì»´í¬ë„ŒíŠ¸ê°€ storeë¥¼ ì‚¬ìš©í•˜ê³  ìˆëŠ” ìƒí™©ì„ ì¬í˜„í•œê²ƒì…ë‹ˆë‹¤. Scopeì„ ì¤‘ì§€í•¨ìœ¼ë¡œì¨ ì»´í¬ë„ŒíŠ¸ì˜ ì–¸ë§ˆìš´íŠ¸ ë˜í•œ ì¬í˜„í–ˆìŠµë‹ˆë‹¤.

í•˜ì§€ë§Œ ì»´í¬ë„ŒíŠ¸ê°€ ì–¸ë§ˆìš´íŠ¸ë˜ë”ë¼ë„ countë¥¼ ë°”ê¿€ë•Œë§ˆë‹¤ watcherê°€ ì‹¤í–‰ë„ë¹„ë‹ˆë‹¤. Watcherì™€ detached scopeì€ ì œê±°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.

```
Simulating component mounting and using store:
Component using store:
watch 1
Store created and used - watcher should be active

Simulating component unmounting:
Component scope stopped

Testing if detached scope was automatically cleaned up:
watch 2
If you see "watch 2" above, the detached scope was NOT cleaned up!
```

## ğŸŒƒ í•´ê²°ì±…: ì°¸ì¡°ì˜ ê°¯ìˆ˜ë¥¼ ê´€ë¦¬í•˜ê¸°

`createSharedComposable`ë¥¼ ì‚¬ìš©í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ì˜ ìˆ˜ë¥¼ ì œëŒ€ë¡œ ì¶”ì í•  ìˆ˜ ìˆë„ë¡ êµ¬í˜„ ë°©ì‹ì„ ë³€ê²½í•´ì•¼ í•©ë‹ˆë‹¤.
ì´ë ‡ê²Œ êµ¬í˜„ ë°©ì‹ì„ ë³€ê²½í•˜ë©´ í•´ë‹¹ composableì„ ì‚¬ìš©í•˜ê³  ìˆëŠ” ë§ˆì§€ë§‰ ì»´í¬ë„ŒíŠ¸ê°€ ì–¸ë§ˆìš´íŠ¸ë  ë•Œ scopeë„ ì •ì§€ë©ë‹ˆë‹¤.

```js
import { effectScope, ref, watch, onScopeDispose } from '@vue/reactivity';

function createSharedComposable(fn) {
  let scope,
    cached,
    refs = 0;

  return (...args) => {
    // composableì´ í˜¸ì¶œë  ë•Œ ì°¸ì¡° ê°¯ìˆ˜ë¥¼ ì¦ê°€
    refs++;

    onScopeDispose(() => {
      // scopeì´ disposed ë  ë•Œ ì°¸ì¡° ê°¯ìˆ˜ ê°ì†Œ
      refs--;

      if (refs === 0 && scope) {
        scope.stop();
        scope = undefined;
        cached = undefined;
      }
    });

    if (!scope) {
      scope = effectScope(true);
      cached = scope.run(() => fn(...args));
    }

    return cached;
  };
}
```

ìš°ì„ , ê³µìœ  composableì— ëŒ€í•œ ì°¸ì¡°ì˜ íšŸìˆ˜ë¥¼ ì¶”ì í•˜ê¸° ìœ„í•´ `refs` ë³€ìˆ˜ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. ì´ í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œë§ˆë‹¤ ì¹´ìš´í„°ë¥¼ ì¦ê°€ì‹œì¼œ ëª¨ë“  ì°¸ì¡°ë¥¼ ì¶”ì í•©ë‹ˆë‹¤.

ë‹¤ìŒìœ¼ë¡œ, `onScopeDispose`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ composableì„ ì‚¬ìš©í•˜ê³  ìˆëŠ” effectê°€ ëª‡ ë²ˆ ë‹«íˆê±°ë‚˜ ì¤‘ì§€ë˜ì—ˆëŠ”ì§€ë¥¼ ì¶”ì í•©ë‹ˆë‹¤.

`onScopeDispose`ëŠ” í•­ìƒ í˜„ì¬ì˜ effect scopeì™€ ì—°ê²°ë¨ì„ ëª…ì‹¬í•˜ì„¸ìš”.
ë”°ë¼ì„œ ë‹¤ë¥¸ ì»´í¬ë„ŒíŠ¸ì—ì„œ ê³µìœ  composableì„ í˜¸ì¶œí•œë‹¤ë©´, `onScopeDispose` í•¨ìˆ˜ëŠ” ì„œë¡œ ë‹¤ë¥¸ effect scopeì™€ ì—°ê²°ë©ë‹ˆë‹¤.

ë§ˆì§€ë§‰ìœ¼ë¡œ `refs`ì˜ ê°’ì´ 0ì´ë˜ë©´ effect scopeì„ ì¤‘ì§€í•´ì•¼ í•©ë‹ˆë‹¤. `refs`ê°€ 0ê³¼ ê°™ì€ì§€ í™•ì¸í•˜ê³ , scopeê°€ ì¡´ì¬í•˜ëŠ”ì§€ë¥¼ í™•ì¸í•œ í›„ì— `scope.stop()`ì„ í˜¸ì¶œí•˜ì—¬ ëª¨ë“  ê²ƒì„ ì •ë¦¬í•©ë‹ˆë‹¤.

## ğŸŒƒ ê²°ê³¼

```
Simulating component mounting and using store:
Component using store:
watch 1
Store created and used - watcher should be active

Simulating component unmounting:
Component scope stopped (reference count should now be 0)

Testing if detached scope was automatically cleaned up:
If you do NOT see "watch 2" above, the detached scope was automatically cleaned up!

The detached scope was automatically cleaned up!
This is the solution - automatic cleanup via reference counting!
```

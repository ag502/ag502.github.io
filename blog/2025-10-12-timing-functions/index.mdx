---
slug: timing-functions
title: Timing Functions
tags: [CSS, Animation]
unlisted: true
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

이 문서는 색인되지 않습니다.

{/* truncate */}

지금까지, 우리는 두가지 방법(CSS transition, CSS keyframe animation)을 사용하여 모션을 구현하는 방법을 살펴봤습니다.

두 기술 모두 같은 원리로 동작합니다. 하나의 상태에서 다른 상태로 즉시 바뀌는것 대신에, 일정 시간동안 두 값 사이를 보간합니다.

```css
.box {
  transition: transform 750ms;
}
```

위 코드는 `transform` 속성이 변경될 때마다, 원래의 값에서 새로운 값으로 변경되는데 750ms가 걸린다는 것을 알려줍니다.

아직 이야기하지 않은 점은 이 보간을 브라우저가 어떻게 처리하는지 입니다.
A에서 B로 값이 변경되는데는 다양한 경로가 있고, 이는 애니메이션의 특성과 분위기에 큰 영향을 미칩니다.

가장 간단한 옵션은 완전히 선형적인 방식으로 움직이는 것 입니다.

<div>
  <img src={require('./linear-ghost.png').default} />
</div>

선형적인 움직임을 사용하면, 원은 정확히 매 프레임마다 정확히 같은 양만큼 움직입니다.

이는 여러 옵션중 하나일 뿐입니다. 초반에 빠르게 움직이다가 나중에 느려지는 옵션도 있습니다.

<div>
  <img src={require('./first-fast-later-slow.png').default} />
</div>

두개의 옵션 모두 시작점과 끝점이 같고, A에서 B까지 도달하는데 걸리는 시간이 같습니다. 바로 위에서 살펴본 옵션이 체감상 더 빨라보이지만 모두 정확히 750ms가 걸립니다.

위 이미지에서 애니메이션이 시작하는 부분은 각 프레임 사이에서 상당히 많이 움직이지만, 애니메이션이 끝날 무렵에는 진행속도가 아주 느려집니다.
결국 원은 같은 거리를 같은 시간동안 이동하지만, 움직임의 분포가 달라져 가속과 감속이 있는 것처럼 보이는 착시 효과를 만들어 냅니다.

애니메이션에서, 우리는 이를 "easing curve" 또는 "tweening" 이라고 부릅니다. 곡선이라고 칭하는 이유는 시간경과에 따른 진행도를 그래프로 나타낼 때, 곡선모양의 그래프가 나오기 때문입니다.

<Tabs>
  <TabItem value="linear" label="linear">
    <img width="50%" src={require('./linear-graph.png').default} />
  </TabItem>
  <TabItem value="ease-in" label="ease-in">
    <img width="50%" src={require('./ease-in-graph.png').default} />
  </TabItem>
  <TabItem value="ease-out" label="ease-out">
    <img width="50%" src={require('./ease-out-graph.png').default} />
  </TabItem>
  <TabItem value="ease-in-out" label="ease-in-out">
    <img width="50%" src={require('./ease-in-out-graph.png').default} />
  </TabItem>
  <TabItem value="ease" label="ease">
    <img width="50%" src={require('./ease-graph.png').default} />
  </TabItem>
</Tabs>

CSS에서 easing curve를 "timing function"을 통해 구현할 수 있습니다. 예를 들어, `cubic-bezier(0, 0, 1, 1)`을 사용하면 선형 easing curve를 만들 수 있습니다.

편의를 위해서, CSS는 이를 추상화한 몇가지 내장 키워드를 제공합니다. `cubic-bezier(0, 0, 1, 1)`을 사용하는 대신에, `linear` 키워드를 사용할 수 있습니다.

Timing function은 CSS transition과 keyframe animation 모두 사용할 수 있습니다.

```css
.box {
  transition: transform 750ms;
  transition-timing-function: linear;
}

.box {
  animation: someAnimationName 750ms;
  animation-timing-function: linear;
}
```

다른 transition/animation 프로퍼티와 마찬가지로, 개별로 명시할 수도 있지만, 하나로 묶어 축약하는게 더 흔한 방법이긴 합니다. 그래서 실제로는 아래와 같이 사용합니다.

```css
.box {
  transition: transform 750ms linear;
  animation: someAnimationName 750ms linear;
}
```

아래는 내장된 키워드가 동작하는 방식을 나타낸 그림입니다.

<Tabs>
  <TabItem value="linear" label="linear">
    <img src={require('./linear-ghost.png').default} />
  </TabItem>
  <TabItem value="ease-in" label="ease-in">
    <img src={require('./ease-in-ghost.png').default} />
  </TabItem>
  <TabItem value="ease-out" label="ease-out">
    <img src={require('./ease-out-ghost.png').default} />
  </TabItem>
  <TabItem value="ease-in-out" label="ease-in-out">
    <img src={require('./ease-in-out-ghost.png').default} />
  </TabItem>
  <TabItem value="ease" label="ease">
    <img src={require('./ease-ghost.png').default} />
  </TabItem>
</Tabs>

각각의 내장 키워드는 목적이 있습니다. 각각의 목적과 어떤걸 사용하면 될지 결정하는 방법을 알아보겠습니다.

## 🌃 구체적인 활용 예시

CSS에 내장된 timing function들을 살펴보았는데, 이것들을 언제 사용해야하는지에 대한 물음이 생깁니다.

이에 대한 답은 상황에 따라 다릅니다. 각각의 timing function마다 가장 잘 맞는 사용 사례가 있습니다. 하나씩 살펴보겠습니다.

### 🎆 linear

저는 `linear` timing function을 회전에 자주 사용합니다. 아래와 같은 로딩 스피너가 예시 입니다.

```css
animation: spin 750ms linear infinite;
```

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <video src={require('./linear-spinner.mov').default} autoPlay loop muted />
</div>

대부분의 경우, 선형 움직임은 인위적인것 처럼 보이지만, 무한한 회전에 적용하면 굉장히 자연스러워 보입니다.

### 🎆 ease-in

`ease-in` timing function은 처음에 천천히 움직였다가 나중에 빠르게 움직이며 설정된 지속시간 후에 멈춥니다.

이 timing function은 퇴장 애니메이션에 유용합니다.

```css
animation: runAway 500ms ease-in;
```

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <video src={require('./ease-in-exiting.mov').default} autoPlay loop muted />
</div>

이 방식은 요소가 화면 밖으로 날아가는 것처럼, 시야 밖에서도 계속 가속하고 있다는 느낌을 주고 싶을 때 유용합니다. 즉, 지속적인 움직임을 표현할 때 적합합니다.

솔직히 말씀드리자면, 기본적인 `ease-in` timing function은 약간 실망스럽습니다. 아이디어는 괜찮지만 timing function의 효과가 너무 약한것 같습니다.

아래에서 나만의 timing function을 만드는 방법을 알아보고, 좀더 극적인 버전의 easing curve를 만들어 보겠습니다.

### 🎆 ease-out

`ease-out`은 `ease-in`과 반대인 timing function 입니다. 따라서 화면 밖에서 나타나는 무언가를 표현하기 적합합니다.

```css
animation: enterFromOffscreen 500ms ease-out;
```

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <video src={require('./ease-out-appear.mov').default} autoPlay loop muted />
</div>

`ease-out`은 점점 느려지면서 멈추기 때문에 움직임이 갑작스럽게 끝나지 않고 자연스럽게 마무리됩니다.

`ease-out` 역시 제 취향은 아닌것 같습니다. 아래에서 좀 더 나은 효과를 만들어 보겠습니다.

### 🎆 ease-in-out

`ease-in-out`은 `ease-in`과 `ease-out`의 조합입니다. 시작할때의 가속과 끝날때의 감속이 정확이 같은 양만큼 발생하기 때문에 완벽히 대칭이라 할 수 있습니다.

이러한 대칭성은 alternate 키워드를 사용할 때 유용합니다. 즉, 값이 두 지점 사이를 오가며 진동(oscillate)할 때 자연스러운 움직임을 만들어줍니다.

```css
animation: oscillate 750ms ease-in-out infinite alternate;
```

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <video
    src={require('./ease-in-out-oscillate.mov').default}
    autoPlay
    loop
    muted
  />
</div>

`linear`는 딱딱한 느낌이고, `ease`는 불균형한 느낌이지만, `ease-in-out`은 이 상황에서 적용하기 완벽합니다.

### 🎆 ease

만약 명시적으로 timing function을 설정하지 않는다면, `ease`가 기본값입니다.

`ease-in-out`과 비슷하지만, 대칭이 아닙니다. 처음에 가속은 짧은시간동안 이루어지지만, 감속은 더 오래걸립니다.

앞서 살펴보았던 timing function들은 사용하기 적합한 상황들이 있었습니다. `ease`는 좀더 광범위하게 사용할 수 있습니다.
이 효과는 꽤 괜찮기 때문에 기본값으로 설정한것이 납득이 됩니다.

```css
animation: transform 500ms ease;
```

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <video src={require('./ease-broad.mov').default} autoPlay loop muted />
</div>

`ease-in-out`과 비교해봤을 때, `ease`는 빠르고 쾌적한 느낌이 드는 반면 `ease-in-out`은 약간 느린 느낌입니다.
또한 `ease`가 감속에 시간을 더 오래 쓰기때문에 좀 더 부드럽습니다.

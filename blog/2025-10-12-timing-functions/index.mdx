---
slug: timing-functions
title: Timing Functions
tags: [secret-css, Animation]
unlisted: true
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

이 문서는 색인되지 않습니다.

{/* truncate */}

지금까지, 우리는 두가지 방법(CSS transition, CSS keyframe animation)을 사용하여 모션을 구현하는 방법을 살펴봤습니다.

두 기술 모두 같은 원리로 동작합니다. 하나의 상태에서 다른 상태로 즉시 바뀌는것 대신에, 일정 시간동안 두 값 사이를 보간합니다.

```css
.box {
  transition: transform 750ms;
}
```

위 코드는 `transform` 속성이 변경될 때마다, 원래의 값에서 새로운 값으로 변경되는데 750ms가 걸린다는 것을 알려줍니다.

아직 이야기하지 않은 점은 이 보간을 브라우저가 어떻게 처리하는지 입니다.
A에서 B로 값이 변경되는데는 다양한 경로가 있고, 이는 애니메이션의 특성과 분위기에 큰 영향을 미칩니다.

가장 간단한 옵션은 완전히 선형적인 방식으로 움직이는 것 입니다.

<div>
  <img src={require('./linear-ghost.png').default} />
</div>

선형적인 움직임을 사용하면, 원은 정확히 매 프레임마다 정확히 같은 양만큼 움직입니다.

이는 여러 옵션중 하나일 뿐입니다. 초반에 빠르게 움직이다가 나중에 느려지는 옵션도 있습니다.

<div>
  <img src={require('./first-fast-later-slow.png').default} />
</div>

두개의 옵션 모두 시작점과 끝점이 같고, A에서 B까지 도달하는데 걸리는 시간이 같습니다. 바로 위에서 살펴본 옵션이 체감상 더 빨라보이지만 모두 정확히 750ms가 걸립니다.

위 이미지에서 애니메이션이 시작하는 부분은 각 프레임 사이에서 상당히 많이 움직이지만, 애니메이션이 끝날 무렵에는 진행속도가 아주 느려집니다.
결국 원은 같은 거리를 같은 시간동안 이동하지만, 움직임의 분포가 달라져 가속과 감속이 있는 것처럼 보이는 착시 효과를 만들어 냅니다.

애니메이션에서, 우리는 이를 "easing curve" 또는 "tweening" 이라고 부릅니다. 곡선이라고 칭하는 이유는 시간경과에 따른 진행도를 그래프로 나타낼 때, 곡선모양의 그래프가 나오기 때문입니다.

<Tabs>
  <TabItem value="linear" label="linear">
    <img width="50%" src={require('./linear-graph.png').default} />
  </TabItem>
  <TabItem value="ease-in" label="ease-in">
    <img width="50%" src={require('./ease-in-graph.png').default} />
  </TabItem>
  <TabItem value="ease-out" label="ease-out">
    <img width="50%" src={require('./ease-out-graph.png').default} />
  </TabItem>
  <TabItem value="ease-in-out" label="ease-in-out">
    <img width="50%" src={require('./ease-in-out-graph.png').default} />
  </TabItem>
  <TabItem value="ease" label="ease">
    <img width="50%" src={require('./ease-graph.png').default} />
  </TabItem>
</Tabs>

CSS에서 easing curve를 "timing function"을 통해 구현할 수 있습니다. 예를 들어, `cubic-bezier(0, 0, 1, 1)`을 사용하면 선형 easing curve를 만들 수 있습니다.

편의를 위해서, CSS는 이를 추상화한 몇가지 내장 키워드를 제공합니다. `cubic-bezier(0, 0, 1, 1)`을 사용하는 대신에, `linear` 키워드를 사용할 수 있습니다.

Timing function은 CSS transition과 keyframe animation 모두 사용할 수 있습니다.

```css
.box {
  transition: transform 750ms;
  transition-timing-function: linear;
}

.box {
  animation: someAnimationName 750ms;
  animation-timing-function: linear;
}
```

다른 transition/animation 프로퍼티와 마찬가지로, 개별로 명시할 수도 있지만, 하나로 묶어 축약하는게 더 흔한 방법이긴 합니다. 그래서 실제로는 아래와 같이 사용합니다.

```css
.box {
  transition: transform 750ms linear;
  animation: someAnimationName 750ms linear;
}
```

아래는 내장된 키워드가 동작하는 방식을 나타낸 그림입니다.

<Tabs>
  <TabItem value="linear" label="linear">
    <img src={require('./linear-ghost.png').default} />
  </TabItem>
  <TabItem value="ease-in" label="ease-in">
    <img src={require('./ease-in-ghost.png').default} />
  </TabItem>
  <TabItem value="ease-out" label="ease-out">
    <img src={require('./ease-out-ghost.png').default} />
  </TabItem>
  <TabItem value="ease-in-out" label="ease-in-out">
    <img src={require('./ease-in-out-ghost.png').default} />
  </TabItem>
  <TabItem value="ease" label="ease">
    <img src={require('./ease-ghost.png').default} />
  </TabItem>
</Tabs>

각각의 내장 키워드는 목적이 있습니다. 각각의 목적과 어떤걸 사용하면 될지 결정하는 방법을 알아보겠습니다.

## 🌃 구체적인 활용 예시

CSS에 내장된 timing function들을 살펴보았는데, 이것들을 언제 사용해야하는지에 대한 물음이 생깁니다.

이에 대한 답은 상황에 따라 다릅니다. 각각의 timing function마다 가장 잘 맞는 사용 사례가 있습니다. 하나씩 살펴보겠습니다.

### 🎆 linear

저는 `linear` timing function을 회전에 자주 사용합니다. 아래와 같은 로딩 스피너가 예시 입니다.

```css
animation: spin 750ms linear infinite;
```

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <video src={require('./linear-spinner.mov').default} autoPlay loop muted />
</div>

대부분의 경우, 선형 움직임은 인위적인것 처럼 보이지만, 무한한 회전에 적용하면 굉장히 자연스러워 보입니다.

### 🎆 ease-in

`ease-in` timing function은 처음에 천천히 움직였다가 나중에 빠르게 움직이며 설정된 지속시간 후에 멈춥니다.

이 timing function은 퇴장 애니메이션에 유용합니다.

```css
animation: runAway 500ms ease-in;
```

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <video src={require('./ease-in-exiting.mov').default} autoPlay loop muted />
</div>

이 방식은 요소가 화면 밖으로 날아가는 것처럼, 시야 밖에서도 계속 가속하고 있다는 느낌을 주고 싶을 때 유용합니다. 즉, 지속적인 움직임을 표현할 때 적합합니다.

솔직히 말씀드리자면, 기본적인 `ease-in` timing function은 약간 실망스럽습니다. 아이디어는 괜찮지만 timing function의 효과가 너무 약한것 같습니다.

아래에서 나만의 timing function을 만드는 방법을 알아보고, 좀더 극적인 버전의 easing curve를 만들어 보겠습니다.

### 🎆 ease-out

`ease-out`은 `ease-in`과 반대인 timing function 입니다. 따라서 화면 밖에서 나타나는 무언가를 표현하기 적합합니다.

```css
animation: enterFromOffscreen 500ms ease-out;
```

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <video src={require('./ease-out-appear.mov').default} autoPlay loop muted />
</div>

`ease-out`은 점점 느려지면서 멈추기 때문에 움직임이 갑작스럽게 끝나지 않고 자연스럽게 마무리됩니다.

`ease-out` 역시 제 취향은 아닌것 같습니다. 아래에서 좀 더 나은 효과를 만들어 보겠습니다.

### 🎆 ease-in-out

`ease-in-out`은 `ease-in`과 `ease-out`의 조합입니다. 시작할때의 가속과 끝날때의 감속이 정확이 같은 양만큼 발생하기 때문에 완벽히 대칭이라 할 수 있습니다.

이러한 대칭성은 alternate 키워드를 사용할 때 유용합니다. 즉, 값이 두 지점 사이를 오가며 진동(oscillate)할 때 자연스러운 움직임을 만들어줍니다.

```css
animation: oscillate 750ms ease-in-out infinite alternate;
```

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <video
    src={require('./ease-in-out-oscillate.mov').default}
    autoPlay
    loop
    muted
  />
</div>

`linear`는 딱딱한 느낌이고, `ease`는 불균형한 느낌이지만, `ease-in-out`은 이 상황에서 적용하기 완벽합니다.

### 🎆 ease

만약 명시적으로 timing function을 설정하지 않는다면, `ease`가 기본값입니다.

`ease-in-out`과 비슷하지만, 대칭이 아닙니다. 처음에 가속은 짧은시간동안 이루어지지만, 감속은 더 오래걸립니다.

앞서 살펴보았던 timing function들은 사용하기 적합한 상황들이 있었습니다. `ease`는 좀더 광범위하게 사용할 수 있습니다.
이 효과는 꽤 괜찮기 때문에 기본값으로 설정한것이 납득이 됩니다.

```css
animation: transform 500ms ease;
```

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <video src={require('./ease-broad.mov').default} autoPlay loop muted />
</div>

`ease-in-out`과 비교해봤을 때, `ease`는 빠르고 쾌적한 느낌이 드는 반면 `ease-in-out`은 약간 느린 느낌입니다.
또한 `ease`가 감속에 시간을 더 오래 쓰기때문에 좀 더 부드럽습니다.

## 🌃 사용자 지정 곡선

지금까지 살펴 보았던 timing function들은 모두 베지에 곡선(Bezier Curve)을 이용해 만들어진 것들입니다.

만약 figma나 Illustrator와 같은 그래픽 소프트웨어를 사용해 본적이 있다면, 베지에 곡선을 본적이 있을것입니다.
베지에 곡선은 곡선을 다른 방향으로 당기기 위해 제어점(control point)이라고 불리는 핸들을 끌어서 만듭니다.

CSS에서 베지어 곡선은 4개의 숫자로 지정되며, 꽤 광범위한 전환 효과를 만들 수 있습니다.
앞서 살펴보았던 `linear`와 `ease-in-out`은 문법적 설탕입니다. 각각은 다른 베지어 곡선으로 표현할 수 있습니다. 예를들어, `ease`는 `cubic-bezier(0.25, 0.1, 0.25, 0.1)`로 표현할 수 있습니다.

멋진점은 내장된 키워드에 의존하지 않아도 된다는 것입니다. 우리만의 베지어 곡선을 정의할 수 있습니다.

## 🌃 멋진 곡선 디자인 하기

베지어 곡선을 만들기 위한 첫번째 단계는 어떤 상황에서 사용되는지를 파악하는 것입니다.

퇴장 애니메이션이나, 화면에서 사라지는 서랍효과를 만든다고 가정해 보겠습니다. 이 경우에는 `ease-in` 곡선이 가장 적합합니다. 초반에 느리지만 점점 가속이 되기 때문입니다.
하지만, `ease-in` 곡선은 약간 아쉽습니다. 가속이 되긴하지만 그 정도가 미미해 `linear`와 비슷해보입니다.

여기서 제가 드리는 첫번째 팁은, 만들려고 하는 애니메이션 효과와 일치하는 내장 전환 효과를 찾은 후 거기서 좀 더 수치를 과장하는 것입니다.
`ease-in`의 경우 `cubic-bezier(0.53, 0, 1, 1)`인데 `cubic-bezier(0.76, 0, 1, 1)`로 변경하게 되면 가속 효과가 극대화 됩니다.

이렇게 하게되면 내장된 `ease-in` 효과보다 더 나은 timing function이 됩니다.

또 다른 예시를 살펴보겠습니다. `ease-in-out`의 경우 앞뒤로 진동하는 효과를 줄때 적합니다. 이 효과도 괜찮지만 대부분의 경우에서 수치를 조정하여 개선할 수 있습니다.
`cubic-bezier(0.42, 0, 0.58, 1)`는 내장된 `ease-in-out`의 수치이고, `cubic-bezier(0.7, 0, 0.3, 1)`로 변경하게 되면 진동 효과가 극대화 됩니다. 이 경우 유의해야할 점은
수치를 크게 변경하게 되면 요소가 흐르는것 처럼 보이지 않고 점프하거나 순간이동하는것 처럼 보인다는 것입니다.

만약 수치를 크게 변경했더라도, 이를 animation duration으로 보완하면 어떻게 될까요?

`ease-out`의 경우를 예로 들어보겠습니다. 이 효과는 화면 밖에서 화면 안으로 들어오거나, 모달이 튀어나오는 효과처럼 멈추기 위해 느려지는 상황에 적합합니다.
`ease-in`효과처럼 약간 미묘하게 아쉽습니다. 따라서 효과를 극대화하기위해 수치를 조정해 보겠습니다.

`ease-out`의 경우 `cubic-bezier(0, 0, 0.58, 1)`인데 `cubic-bezier(0, 0, 0, 1)`로 변경해도 자연스럽지 않은거 같습니다.
첫번째 제어점도 움직여 수치를 조정한 후, animation duration을 1500ms로 늘려보겠습니다.

매우 흥미롭습니다. 1500ms는 터무니 없는 수치입니다. 애니메이션 가이드라인에 100ms~200ms는 빠르고, 300ms는 보통이며 500ms이상은 느리다고 나와있습니다. 1500ms는 이 수치의 3배입니다.

하지만 실제로 애니메이션은 꽤 빠른거 처럼 느껴집니다. 움직임의 90퍼센트가 초반 수백 밀리초안에 발생하기 때문입니다. 정지가 부드럽게 느껴질 수 있도록 꽤 많은 시간은 마지막에 씁니다.

## 🌃 파티클 애니메이션에 적절한 베지어 곡선

지금까지 살펴본 내용을 바탕으로 파티클 애니메이션에 적용하면 좋을 효과를 생각해보겠습니다. 고민해본 결과 다음과 같은 효과가 적합할거 같습니다.

```css
.like-button {
  animation:
    fadeToTransparent 1100ms forwards,
    fromCenter 600ms forwards cubic-bezier(0.2, 0.56, 0, 1);
}
```

빠르게 시작하지만 감속이 길어 마지막 순간이 자연스럽고 유기적으로 보일것 입니다.

Timing function을 `fromCenter`에만 적용한 것을 주목해주세요. `fadeToTransparent`에도 적용할 수 있었지만 사라지는 애니메이션에 timing function은 큰 의미가 없었습니다.

`fadeToTransparent`의 duration을 1100ms로 설정하여 흩어지는 모션보다 길게 유지되도록 설정했습니다.

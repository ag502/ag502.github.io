---
slug: understanding-effect-scope
title: Effect Scope 이해하기
tags: [vue, vue-reactivity]
unlisted: true
---

이 문서는 색인되지 않습니다.
{/* truncate */}

Effect Scope은 Vue의 반응성에서 필수적인 요소 중 하나입니다. Effect Scope에 대해 자세히 몰라도 이미 사용하고 있습니다.

컴포넌트 안에서 watcher나 computed property, 반응성이 있는 데이터를 선언하면 Vue는 effect scope을 통해 자동으로 그것들의 cleanup 함수를 추적합니다.

## 🌃 예시

```html
<!-- App.vue -->
<template>
  <div class="lesson-container">
    <h1>Lesson 1: Understand Effect Scopes</h1>
    <div class="demo">
      <p>Count: {{ count }}</p>
      <p>
        Check the console to see the watcher logs and effect scope information.
      </p>
    </div>
  </div>
</template>

<script setup lang="ts">
  import { ref, watch, getCurrentScope } from 'vue';

  const count = ref(0);

  // watcher는 컴포넌트가 unmounted될 때 자동으로 cleanup이 됩니다.
  watch(count, (n) => {
    console.log('component watcher', n);
  });

  console.log('Current scope:', getCurrentScope()); // EffectScope 객체

  setInterval(() => {
    count.value++;
  }, 1000);
</script>
```

위 예시는 모든 컴포넌트에서 자동으로 effect scope을 관리하는 것을 보여줍니다.

## 🌃 Effect Scope이 동작하는 방식

컴포넌트가 setup 함수를 실행하는 동안, Vue는 새로운 effect scope을 생성합니다. 추가된 반응형 effect들은 생성된 scope에 의해 추적됩니다.

```ts
const count = ref(0);
watch(count, (n) => {
  console.log('component watcher', n);
});
console.log('Current scope:', getCurrentScope());
```

위 코드를 실행시키면 아래와 같은 결과나 출력됩니다.

```
Current scope: EffectScope { effects: [ReactiveEffect, ReactiveEffect], ...}
component watcher 1
component watcher 2
component watcher 3
```

Effect SCope은 두개의 반응형 effect를 포함하고 있습니다. 하나는 watcher이고 다른 하나는 컴포넌트 update 함수 입니다.

## 🌃 Effect Scope 검사하기

Effect Scope 객체는 Vue의 내부 추적 기능을 보여줍니다.

```
{
 cleanups: [],
 detached: true,
 effects: [
    ReactiveEffect, // your watcher
    ReactiveEffect // Component update function
 ]
}
```

첫번째 effect는 컴포넌트 내부에 선언한 watcher 이고, 두번째는 반응형 값이 변경될때 탬플릿을 re-render해주는 컴포넌트 업데이트 함수 입니다.

Watcher를 선언한 코드를 주석처리 하고 scope을 다시 확인해보면 ReactiveEffect가 하나만 남은것을 볼 수 있습니다.

## 🌃 자동 cleanup

컴포넌트가 unmounted 될 때, Vue는 `scope.stop()`을 effect scope에서 호출합니다. 이 호출을 통해 모든 effect들의 추적을 멈추고 메모리 누수를 방지합니다.

```ts
// https://github.com/ag502/core/blob/main/packages/runtime-core/src/renderer.ts#L2289
const unmountComponent = (
  instance: ComponentInternalInstance,
  parentSuspense: SuspenseBoundary | null,
  doRemove?: boolean,
) => {
  // 생략

  // stop effects in component scope
  scope.stop();

  // 생략
};
```

이렇게 자동으로 cleanup 함수를 호출하면 컴포넌트가 파괴될 때, watcher가 더 이상 실행되지 않게 됩니다.

## 🌃 Effect Scope이 중요한 이유

Effect Scope이 없다면 모든 watcher와 computed 속성, 반응형 데이터를 수동으로 추적해야하며 수동으로 추적을 해제해야 합니다.
Vue는 복잡한 작업을 대신 해주지만, 어떻게 동작하는지 이해하는 것은 더 나은 반응형 코드를 작성할 수 있게 도와주며 문제가 발생했을 때 디버깅하는데 도움이 됩니다.

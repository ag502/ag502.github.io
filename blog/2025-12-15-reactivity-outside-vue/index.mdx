---
slug: reactivity-outside-vue
title: Vue 바깥에서의 반응성
tags: [secret-vue, vue-reactivity]
unlisted: true
---

이 문서는 색인되지 않습니다.
{/* truncate */}

Vue 반응형 시스템의 가장 강력한 점은 Vue에 의존적이지 않다는 점 입니다. Vue의 반응형 시스템을 일반 자바스크립트 애플리케이션과 함께 쓸 수 있습니다.

Vue의 반응형 시스템은 별도의 패키지로 배포되어 있어, 프레임워크에 비의존적입니다.

## 🌃 예시

```js
import { effectScope } from '@vue/reactivity';

function runDemo() {
  const scope = effectScope();
  console.log(scope);
}

runDemo();
```

위 코드는 Vue 컴포넌트나 애플리케이션 밖에서 scope를 생성한 예시입니다.

## 🌃 독립적인 effect scope 만들기

`effectScope` 함수는 Vue가 내부에서 생성하는 scope와 동일하게 새로운 scope를 생성합니다.

```js
import { effectScope } from '@vue/reactivity';

const scope = effectScope();
console.log(scope);
```

위 코드를 실행시키면 아래와 같은 결과를 확인할 수 있습니다.

```
EffectScope {
  detached: false,
  _active: true,
  _on: 0,
  effects: [],
  cleanups: [],
  _isPaused: false,
  parent: undefined,
}
```

위 결과는 Vue 컴포넌트에서 봤던것과 동일하지만 완벽하게 독립적입니다.

## 🌃 Vue 밖에서 effect scope 만들기

위 에서 살펴보았듯이 순수 자바스크립트에서 effect scope을 생성하고 수동으로 관리할 수 있습니다. 이를 통해 반응형 effect가 추적되고 clean up 되는것을 제어할 수 있습니다.

### 🎆 Effect Scope이 없을 때의 문제점

적절한 scope 관리가 없다면 반응형 effect는 계속 실행됩니다.

```js
import { ref, watch } from '@vue/reactivity';

async function runDemo() {
  const n = ref(0);

  watch(n, (v) => {
    console.log(v);

    if (v === 5) {
      // watcher 실행 정지
    }
  });

  setInterval(() => {
    n.value = n.value + 1;
  }, 200);
}
```

위 코드에서 watcher는 실행을 멈추지 않습니다. Interval 함수가 값을 계속 증가시킵니다.

### 🎆 해결책

```js
import { ref, watch, effectScope } from '@vue/reactivity';

async function runDemo() {
  const scope = effectScope();

  scope.run(() => {
    const n = ref(0);

    watch(n, (v) => {
      console.log(v);

      if (v === 5) {
        scope.stop();
      }
    });

    setInterval(() => {
      n.value = n.value + 1;
    }, 200);
  });
}
```

위 코드는 반응형 코드를 effect scope으로 감싸고, 조건을 충족할 때 반응형이 실행되지 않도록 합니다.

### 🎆 Scope이 실행을 제어하는 방식

`effectScope` 함수는 effect를 추적하고 clean up 하는 scope을 생성합니다.

```js
const scope = effectScope();
```

`scope.run` 함수는 effect scope 컨텍스트 내부의 코드를 실행시킵니다.

```js
scope.run(() => {
  // scope 내부의 반응형 effect들은 scope에 의해 추적됩니다.
  const n = ref(0);
  watch(n, (v) => {
    console.log(v);
  });
});
```

`scope.stop` 함수는 추적중인 모든 effect들을 중단시킵니다.

```js
if (v === 5) {
  scope.stop();
}
```

## 🌃 Vue 밖에서 반응형 시스템을 사용하는 이유

Vue 밖에서 반응형 시스템을 사용하면 많은 가능성이 열립니다.

다양한 프레임워크에서 동작하거나 바닐라 자바스크립트에서 동작하는 반응형의 데이터 스토어를 만들 수 있습니다.

반응성을 가진 Vue에 독립적인 라이브러리를 만들 수도 있습니다.

Vue의 안정적인 반응형 시스템을 사용하면 데스크톱 앱, CLI 도구나 서버 사이드 애플리케이션을 만들 수도 있습니다.

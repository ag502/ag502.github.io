---
slug: components
title: Components
tags: [react, learning-react]
unlisted: true
---

이 문서는 색인되지 않습니다.

{/* truncate */}

컴포넌트은 리액트에서 큰 부분을 차지합니다. 만약 리액트에 대해 딱 한가지만 알아야 한다면, 그것은 아마 리액트가 컴포넌트에 기반하고 있는 프레임워크라는 것일겁니다.

컴포넌트는 무엇일까요? 컴포넌트는 마크업과 스타일 그리고 유저 인터페이스를 컨트롤하는 로직을 하나로 묶은 번들로 정의하고 싶습니다.

코드 구성에 있어서 완전히 다른 사고방식이 필요합니다. 마크업과 스타일, 로직을 분리하는것 대신에 컴포넌트로 구성합니다.

이를 잘 설명한 이미지가 있습니다.

<div>
  <img src={require('./separation-of-concerns.jpg').default} />
</div>

위 이미지는 Cristiano Rastelli가 작성한 것입니다.

## 🌃 재사용 메커니즘

전통적인 HTML에서는 마크업을 재사용하기 위한 방법이 없었습니다. 많은 언어들이 재사용을 하기위해 코드의 일부분을 분리하는 방법을 사용했습니다.
HTML의 일부분을 분리해 다른 HTML에 삽입하는 방법을 사용했습니다.

CSS에서 재사용을 위한 메커니즘은 _class_ 입니다. 예를 들어, 공통으로 사용될 "button" 스타일을 `btn` 클래스로 정의할 수 있습니다.

```css
.btn {
  padding: 8px 32px;
  background: blue;
  border: none;
  font-size: 1rem;
}
```

HTML 요소에 위 스타일을 적용하려면 `btn` 클래스를 추가하면 됩니다.

자바스크립트의 재사용 메커니즘은 _함수_ 입니다.

```js
function shout(sentence) {
  return sentence.toUpperCase() + '!!';
}

shout("we're off to see the wizard");
// -> "WE'RE OFF TO SEE THE WIZARD!!"
```

리액트에서 컴포넌트는 재사용을 위한 메인 메커니즘입니다. HTML코드의 일부분이나, CSS 클래스, 자바스크립트의 함수보다 이 세가지를 모두 묶어주는 컴포넌트를 만들어, 재사용 가능한 고수준의 UI 요소 라이브러리를 구축할 수 있도록 합니다.

## 🌃 기본 구문

아래의 예시를 살펴보겠습니다.

```js
import React from 'react';
import { createRoot } from 'react-dom/client';

function FriendlyGreeting() {
  return (
    <p style={{ fontSize: '1.25rem', textAlign: 'center', color: 'sienna' }}>
      Greetings, weary traveller!
    </p>
  );
}

const container = document.querySelector('#root');
const root = createRoot(container);
root.render(<FriendlyGreeting />);
```

리액트에서 컴포넌트는 자바스크립트 함수로 정의됩니다. `class` 키워드를 사용하여 정의할 수도 있지만, 현대의 리액트 애플리케이션에서는 추천하지 않는 레거시입니다.

일반적으로, 리액트 컴포넌트는 하나 이상의 리액트 요소를 반환합니다.

`FriendlyGreeting` 컴포넌트는 paragraph를 가진 리액트 요소를 생성하고 몇 가지 내장 스타일을 적용합니다.

HTML 태그를 랜더링했던 방식과 동일하게 컴포넌트도 랜더링합니다. 하지만 `div`나 `h1`을 랜더링하는것이 아닌, `FriendlyGreeting` 을 랜더링 했습니다.

:::info 화살표 함수 vs 일반 함수도
모던 자바스크립트에서는 함수를 작성하기 위해 사용할 수 있는 두가지 방법이 있습니다.
`function` 키워드를 사용하는 전통적인 방법외에 "화살표 함수"를 사용할 수 있습니다.

리액트 컴포넌트를 정의하기 위해서는 어떤 방법을 사용해야 할까요? 정답은 상관없다 입니다. 둘다 동일하게 동작합니다.

```js
const FriendlyGreeting = () => (
  <p
    style={{
      fontSize: '1.25rem',
      textAlign: 'center',
      color: 'sienna',
    }}
  >
    Greetings, weary traveller!
  </p>
);
```

화살표 함수를 사용하면, _this_ 키워드를 사용하지 못하거나, 생성자를 호출할 수 업다는 함수적인 제약사항이 있지만, 리액트 컴포넌트에는 상관없습니다.
화살표 함수는 전통적인 함수와 동일하게 동작합니다.
:::

### 🎆 반드시 지켜야할 규칙

컴포넌트를 생성할 때 지켜야할 규칙이 많은것은 아닙니다만, 반드시 지켜야할 규칙은 있습니다. 그것은 반드시 컴포넌트의 이름은 대문자로 시작해야 한다는 것입니다.
JSX 컴파일러가 대문자의 사용여부를 통해 내장된 HTML 태그를 랜더링 할지 아니면 커스텀 컴포넌트를 랜더링할 지를 결정하기 때문입니다.

예를 들어, 다음 두개의 JSX 요소를 살펴보겠습니다.

```js
const heading = <h1>Hello!</h1>;
const greeting = <FriendlyGreeting />;
```

위 코드를 자바스크립트로 변환한 결과는 다음과 같습니다.

```js
const heading = React.createElement('h1', null, 'Hello!');
const greeting = React.createElement(FriendlyGreeting, null);
```

리액트 요소는 우리가 생성하고 싶은것에 대한 설명서입니다. 어떤 경우에는 `<h1>`이나 `p`와 같은 DOM node를 생성하고 싶을 때가 있습니다. 또 다른 경우에는 컴포넌트 인스턴스를 생성하고 싶을 때도 있습니다.

`React.createElement` 함수에 전달하는 첫번째 인자는 생성하고자 하는 "type" 입니다. 첫번째 요소는 문자열("h1")입니다.
두번째 요소는 함수 입니다! `FriendlyGreeting` 이지 `"FriendlyGreeting"` 이 아닙니다.

모든 리액트 컴포넌트의 이름은 PascalCase를 사용해야 하지만 엄밀히 말하면 첫 글자가 중요합니다. `FriendlyGreeting`이 컨벤션 규칙에 맞지만 `Friendlygreeting`으로 명명해도 문제는 없습니다.

:::info 왜 문자열의 대소문자로 판단을 할까요?
언뜻 보면 이 규칙이 다소 불필요해 보입니다. 사실 리액트는 HTML 태그를 랜더링할건지 컴포넌트를 랜더링할건지 알 수 있지 않을까요?
내장된 HTML 태그는 한정되어 있잖아요

안타깝게도 그렇게 단순한 문제는 아닙니다.

"대문자 규칙"이 없다고 가정하고 아래와 같은 코드가 있다고 해봅시다.

```js
const element = <button />;
```

내장된 `<button>` HTML 태그를 랜더링 해야할까요? 아니면 사용자가 정의한 `button` 컴포넌트를 랜더링해야 할까요?
어쨌든 많은 컴포넌트 라이브러리에는 "button" 컴포넌트가 있습니다.

어쩌면 새로운 규칙을 만들 수도 있겠습니다. 컴포넌트는 HTML 태그의 이름을 가질 수 없다는 규칙이요. 그렇게 하려면, 리액트는 모든 내장 HTML 태그의 목록을 가지고 있어야 하며 이 태그들은 "예약어"로 간주될 것입니다.

괜찮아 보이지만 새로운 HTML 태그가 나올때 문제가 됩니다. HTML 목록은 고정된것이 아닙니다.
만약 W3C가 새로운 태그를 추가한다면 리액트 애플리케이션은 동작하지 않게될 것 입니다.
:::

## 🌃 Props

지금까지, `FriendlyGreeting` 컴포넌트는 꽤 괜찮았지만 사용성은 떨어집니다. `FriendlyGreeting` 컴포넌트를 사용할 때마다 같은 결과를 얻는데 이는 유연하지 않습니다.

다행이도, 컴포넌트는 `props`라 불리는 것을 가지고 있습니다. Props는 함수의 인자와 비슷합니다.
`Props`는 컴포넌트에 데이터를 전달하여 이를 바탕으로 커스터마이즈 할 수 있게 해줍니다.

이제 `FriendlyGreeting` 컴포넌트가 이름을 받아서 랜더링하도록 수정해보겠습니다.

```js
function FriendlyGreeting({ name }) {
  return (
    <p
      style={{
        fontSize: '1.25rem',
        textAlign: 'center',
        color: 'sienna',
      }}
    >
      Greetings, {name}!
    </p>
  );
}
```

표현식 슬롯을 사용하여 `Greeting, {name}`으로 바꿨습니다. 그런데 `name`은 어디서 오는걸까요?
리액트는 HTML 요소에 데이터를 전달하는 방식과 동일하게 데이터를 전달합니다. 만약 요소에 ID를 전달하고 싶다면 `<div id="some-div"></div>`와 같이 속성을 전달할 수 있습니다.
리액트 요소에서도 동일합니다. `<FriendlyGreeting name="Josh">`로 전달 할 수 있습니다.

리액트가 랜더링될 때 모든 props는 `props` 객체에 저장됩니다. 따라서 `name` 값을 JSX에서 `{props.name}`으로 접근할 수 있습니다.
리액트 커뮤니티에서는 구조 분해 할당을 사용하는 것이 더 일반적입니다.

### 🎆 Default values

`FriendlyGreeting`를 사용할 때 문제점이 있습니다. 모든 사람의 이름을 알지 못한다는 것입니다.
만약 이름을 모른다면 "fallback" 값을 노출해야 합니다.

```
// If I know their name:
Hey Josh!

// If not:
Hey there!
```

`||` 연산자를 해결해서 아래와 같이 사용할 수 있습니다.

```js
function FriendlyGreeting({ name }) {
  return <p>Hey {name || 'there'}!</p>;
}
```

만약 `name`이 있으면 그 값을 사용하고 그렇지 않으면 "there"를 사용합니다.

이 방법도 통하지만 리액트에서는 더 좋은 방법이 있습니다. 각각의 props에 기본값을 설정할 수 있습니다.

```js
function FriendlyGreeting({ name = 'there' }) {
  return <p>Hey {name}</p>;
}
```

이 방법에는 몇가지 장점이 있습니다.

- 만약 기본값을 설정할 props가 여러개라면 기본값들을 한 곳에서 확인할 수 있습니다.
- 기본값은 고정되어 있습니다. `name` props를 참조할 때 마다 fallback 값을 확인하지 않아도 됩니다
- `||` 연산자는 값이 있음에도 기본값을 반환할 때가 있는데, falsy한 값을 전달하면 그렇게 됩니다.

결론적으로 props 객체에 기본값을 지정한는것은 잘 설계된 컨벤션입니다.

:::info Nullish Coalescing 연산자
Fallback 값을 설정하는 또다른 방법은 nullish coalescing 연산자를 사용하는 것입니다.

```js
function FriendlyGreeting({ name }) {
  return <p>Hey {name ?? 'there'}</p>;
}
```

해당 연산자는 `||`와 비슷하지만 nullish한 값(null 또는 undefined)만을 허용합니다. 다시말해, `0`과 같은 falsy 값에 대해 걱정할 필요가 없습니다.
:::

:::warning "defaultProps" 속성
이전 버전의 리액트에서는, 컴포넌트에 명시적으로 적용할 수 있는 `defaultProps` 속성이 있었습니다.
하지만 이제 `defaultProps` 속성은 더이상 사용하지 않습니다.
:::

## 🌃 The Children Prop

커스텀 버튼 컴포넌트를 만들고 있다고 가정해 보겠습니다. 보통의 HTML 버튼처럼 보이고 작동해야 하지만, 붉은 배경에 흰 텍스트를 가져야 합니다.

아래와 같이 작성할 수 있습니다.

```js
function RedButton({ contents }) {
  return (
    <button style={{ color: 'white', backgroundColor: 'red' }}>
      {contents}
    </button>
  );
}
```

그리고 아래처럼 사용할 수 있습니다.

```js
root.render(<RedButton contents="Don't click me" />);
```

동작은 잘 하지만... 다소 웃깁니다. 그렇지 않나요? 일반적인 HTML 버튼처럼 컨텐츠가 태그 사이에 들어가는 방식과는 다소 다릅니다.

```html
<button>Don't click me</button>
```

리액트는 HTML과 동일하게 사용할 수 있도록 문법적 설탕(syntactic sugar)을 제공합니다.

```js
root.render(<RedButton>Do not click me</RedButton>);
```

위와 같이 사용하려면 `children` props를 통해 children에 접근해야 합니다.

```js
function RedButton({ children }) {
  return (
    <button style={{ color: 'white', backgroundColor: 'red' }}>
      {children}
    </button>
  );
}
```

이것은 리액트가 제공하는 편의기능입니다. 태그 사이에 무언가를 넣으면 리액트는 자동으로 값을 `children` props에 할당합니다.

생성된 리액트 요소를 출력해보면 알 수 있습니다.

```js
import React from 'react';

const element = <div>Hello World!</div>;

console.log(element);
```

```
{
  "type": "div",
  "key": null,
  "props": {
    "children": "Hello World"
  },
  "_owner": null,
  "_store": {}
}
```

`children`은 `props`에 있어서 예약어입니다.

하지만 그렇게 특별하지는 않습니다. 리액트를 처음 배우는 사람들은 `children`을 다른 props와 다른것으로 생각하는데 사실 동일합니다.

원한다면, `children`을 일반적인 props를 전달하는 것과 동일하게 전달할 수 있습니다. 조금 어색하지만 결과는 동일합니다.

```js
// eslint-disable-next-line react/no-children-prop
<div children="Hello World!"></div>
```

```js
<div>Hello World!</div>
```

:::info 둘다 전달하면 어떻게 될까요?
만약 두가지 형태로 전달하면 어떻게 될까요?

```js
import React from 'react';
import { createRoot } from 'react-dom/client';

// eslint-disable-next-line react/no-children-prop
const element = <div children="As an attribute">Between the brackets</div>;

const root = createRoot(document.querySelector('#root'));
root.render(element);
```

위 코드를 실행하면 'Between the brackets'가 출력됩니다.

리액트가 태그 사이에 전달된 `children`에 더 높은 우선순위를 부여합니다. 제 생각에는 이게 더 맞는 방법인 것 같습니다.
요소의 자식을 설정한는 것이 더 일반적이니까요

이것이 리액트 개발팀의 의도된 설계인지 아니면 단순히 두번째 인자가 첫번째 인자를 덮어쓴것인지 궁금해할 수도 있습니다.

이 질문에 대한 답을 살펴보기 위해 자바스크립트로 컴파일된 코드를 먼저 살펴보겠습니다.

```js
// eslint-disable-next-line react/no-children-prop
const element = React.createElement(
  'div',
  { children: 'As an attribute' },
  'Between the brackets',
);
```

`createElement` 함수에 두개의 값이 다른 인자로 전달됐음을 알 수 있습니다. 이를 통해 리액트 팀의 의도된 설계임을 알 수 있습니다.
:::

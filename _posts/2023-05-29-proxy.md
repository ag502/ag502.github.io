---
title: Proxy
date: 2023-05-29
categories: [JavaScript]
tags: [JavaScript, Proxy]
---

## 💻 Proxy란?

![proxy](/assets/img/proxy/proxy.png)

`Proxy`는 객체를 감싸 객체에 대한 기본 작업을 가로채고 재정의하는 객체입니다.  
가로채진 작업은 위의 왼쪽과 그림과 같이 원래 객체가 처리하도록 그대로 전달 되거나, 오른쪽 그림과 같이 `Proxy` 객체 자체에서 처리되기도 합니다.

`Proxy`를 활용한 대표적인 프레임워크는 `Vue3`로, `reactivity`를 구현하기위해 `Proxy`를 사용했습니다.

## 💻 Proxy 생성

```typescript
const proxiedObject = new Proxy(target, handler);
```

위 예시처럼 두 개의 매개변수를 사용하여 `Proxy` 객체를 선언합니다.

- `target`: 프록시할 (감싸게될) 원본 객체로, 함수를 포함한 모든 객체가 가능합니다.
- `handler`: 가로채는 작업과 그 작업을 재정의(trap)한 것들을 모아놓은 객체입니다.

`Proxy` 객체에 작업이 가해졌을 때, `handler`에 그와 상응하는 작업(trap)이 있으면 `Proxy` 객체가 작업을 처리하게되고 없다면 원본객체 (`target`)가 해당 작업을 수행하게 됩니다.

```typescript
const target: Record<string, any> = {};

const proxiedObject = new Proxy(target, {});

proxiedObject.message1 = "Hello";

console.log(target.message1); // Hello

console.log(target.message1); // Hello
```

위 예시 볼 수 있듯이 `ProxiedObject`에 message1 프로퍼티를 추가한 작업이, `target`에도 적용되었음을 볼 수 있습니다.  
이는 `Proxy` 객체에 빈 `handler`가 전달되었음으로, `Proxy`객체에 가해진 작업들은 모두 원본객체로 전달되었기 때문입니다.

## 💻 Handler Methods

`Proxy`객체의 `trap`은 객체의 내부 매서드 호출을 가로챕니다. [`Proxy`가 가로채는 내부 메서드 리스트](https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots)는 아래와 같습니다.

|    Internal Method    |       Handler Method       |                                              동작 시점                                               |
| :-------------------: | :------------------------: | :--------------------------------------------------------------------------------------------------: | ------ | ----------------- |
|  [[GetPrototypeOf]]   |      `getPrototypeOf`      |                                   `Object.getPrototypeOf` 호출 시                                    |
|  [[SetPrototypeOf]]   |      `setPrototypeOf`      |                                   `Object.setPrototypeOf` 호출 시                                    |
|   [[isExtensible]]    |       `isExtensible`       |                                    `Object.isExtensible` 호출 시                                     |
| [[preventExtension]]  |    `preventExtensions`     |                                  `Object.preventExtensions` 호출 시                                  |
|  [[GetOwnProperty]]   | `getOwnPropertyDescriptor` |                 `Object.getOwnPropertyDescriptor` <br> `for..in` <br> `Object.[keys                  | values | entries]` 호출 시 |
| [[DefineOwnProperty]] |      `defineProperty`      |                                   `Object.defineProperty` 호출 시                                    |
|    [[HasProperty]]    |           `has`            |                                          `in` 연산자 사용시                                          |
|        [[Get]]        |           `get`            |                                          프로퍼티를 읽을 때                                          |
|        [[Set]]        |           `set`            |                                           프로퍼티를 쓸 때                                           |
|      [[Delete]]       |      `deleteProperty`      |                                       `delete` 연산자 사용 시                                        |
|  [[OwnPropertyKeys]]  |         `ownKeys`          | `Object.getOwnPropertyNames`, <br> `Object.getOwnPropertySymbols`, <br> `for..in` <br> `Object.[keys | values | entries]` 호출 시 |
|       [[Call]]        |          `apply`           |                                           함수를 호출할 때                                           |
|    [[Constructor]]    |       `constructor`        |                                        `new` 연산자가 사용 시                                        |

## 💻 [[Get]]

가장 흔하게 사용되는 `Proxy handler`의 트랩으로 프로퍼티를 읽을 때 사용됩니다.  
`get` 트랩을 사용하기 위해서는 `handler`에 `get` 메소드가 있어야 합니다.

```typescript
function get(target: T, property: string | symbol, receiver: any): any;
```

- target: 동작을 전달한 대상객체 (원본객체) 입니다.
- property: 가져올 프로퍼티의 이름또는 `Symbol` 입니다.
- receiver: `Proxy` 또는 `Proxy`에서 상속되는 객체로 `get`이 동작할 때 `this`를 의미합니다. 보통 `Proxy`객체가 `this`가 되지만, 만약 `Proxy`객체를 상속받은 객체가 있다면 해당 객체가 `this`가 됩니다.

예시를 통해 `get` `trap`을 사용해보겠습니다.

```typescript
const numbers = [0, 1, 2];

const proxiedNumbers = new Proxy(numbers, {
  get(target, property) {
    if (property in target) {
      return target[Number(property)];
    } else {
      return 0;
    }
  },
});

console.log(numbers[3]); // undefined

console.log(proxiedNumbers[1]); // 1
console.log(proxiedNumbers[3]); // 0
```

위 코드는 존재하지 않는 원소 접근 시 0을, 존재하는 원소 접근 시 해당 원소를 리턴하는 `Proxy` 객체입니다.

#### 🖊 주의할 점

> `Proxy` 객체를 사용할 때, 원본객체 (타깃객체)를 참조하는 것을 지양해야합니다.

## 💻 [[Set]]

`set` 트랩은 프로퍼티에 값을 쓸 때, 사용하는 `Proxy handler` 입니다.

```typescript
function set(
  target: T,
  property: string | symbol,
  newValue: any,
  receiver: any
): boolean;
```

- target: 동작을 전달한 대상객체 (원본객체) 입니다.
- property: 설정할 프로퍼티의 이름또는 `Symbol` 입니다.
- newValue: 설정할 프로퍼티의 새 값 입니다.
- receiver: `get` 트랩과 유사하게 동작하는 객체입니다.

#### 🖊 주의할 점

> 값을 쓰는것이 완료되면 `true`, 그렇지 않은 경우는 반드시 `false`를 반환해야 합니다.

```typescript
const numbers: number[] = [];

const proxiedNumbers = new Proxy(numbers, {
  set(target, property, newValue) {
    if (typeof newValue === "number") {
      target[Number(property)] = newValue;
      return true;
    } else {
      return false;
    }
  },
});

proxiedNumbers.push(1);
proxiedNumbers.push(2);
console.log(proxiedNumbers.length); // 2

proxiedNumbers.push("a"); // 'set' on proxy: trap returned falsish for property
```

위 예시는 배열에 숫자원소만 추가할 수 있게끔 `set` 트랩으로 값을 검증하는 코드입니다.  
숫자일 경우 `true`를 반환해 정상적으로 추가 되었음을 알리고, 그렇지 않을 경우 `false`를 반환해 에러를 발생 시킴니다.
